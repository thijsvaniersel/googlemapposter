{"version":3,"file":"index.js","sources":["src/component/select-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/select-interaction/interaction.vue","src/component/select-interaction/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport debounce from 'debounce-promise'\nimport { never, shiftKeyOnly, singleClick } from 'ol/events/condition'\nimport Feature from 'ol/Feature'\nimport SelectInteraction from 'ol/interaction/Select'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { map as mapOp } from 'rxjs/operators'\nimport Vue from 'vue'\nimport { featuresContainer, interaction, projTransforms, stylesContainer } from '../../mixin'\nimport { createStyle, defaultEditStyle, getFeatureId, getLayerId, initializeFeature } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasInteraction, hasMap } from '../../util/assert'\nimport { constant, difference, forEach, isEqual, isFunction, mapValues, stubArray } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nexport default {\n  name: 'vl-interaction-select',\n  mixins: [interaction, featuresContainer, stylesContainer, projTransforms],\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        id: this.vmId,\n        class: this.cmpName,\n      }\n    },\n  },\n  props: {\n    /**\n     * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.\n     * @type {function|undefined}\n     */\n    filter: {\n      type: Function,\n      default: constant(true),\n    },\n    /**\n     * A list of layers from which features should be selected. Alternatively, a filter function can be provided.\n     * @type {string[]|function|undefined}\n     */\n    layers: {\n      type: [Array, Function],\n      default: undefined,\n    },\n    /**\n     * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.\n     * This only works for the canvas renderer and not for WebGL.\n     * @type {number}\n     */\n    hitTolerance: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * A boolean that determines if the default behaviour should select only single features or all (overlapping)\n     * features at the clicked map position.\n     * @type {boolean}\n     */\n    multi: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * Selected features as array of GeoJSON features with coordinates in the map view projection.\n     * @type {string[]|number[]|Object[]}\n     */\n    features: {\n      type: Array,\n      default: stubArray,\n    },\n    /**\n     * Wrap the world horizontally on the selection overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should\n     * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events\n     * for `add` and `remove` instead of `toggle`.\n     * @type {function|undefined}\n     */\n    addCondition: {\n      type: Function,\n      default: never,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.\n     * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature\n     * removes all from the selection.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: singleClick,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`\n     * instead of `toggle`.\n     * @type {function|undefined}\n     */\n    removeCondition: {\n      type: Function,\n      default: never,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`\n     * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,\n     * and removes it if it is.\n     * @type {function|undefined}\n     */\n    toggleCondition: {\n      type: Function,\n      default: shiftKeyOnly,\n    },\n  },\n  computed: {\n    initializedFeature () {\n      return this.features.map(feature => initializeFeature({ ...feature }))\n    },\n    layerFilter () {\n      return Array.isArray(this.layers)\n        ? layer => this.layers.includes(getLayerId(layer))\n        : this.layers\n    },\n  },\n  methods: {\n    /**\n     * @return {Select}\n     * @protected\n     */\n    createInteraction () {\n      return new SelectInteraction({\n        features: this.$featuresCollection,\n        multi: this.multi,\n        wrapX: this.wrapX,\n        filter: this.filter,\n        layers: this.layerFilter,\n        hitTolerance: this.hitTolerance,\n        style: this.createStyleFunc(),\n        addCondition: this.addCondition,\n        condition: this.condition,\n        removeCondition: this.removeCondition,\n        toggleCondition: this.toggleCondition,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n      this.features.forEach(this.select)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unselectAll()\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {void}\n     * @throws {Error}\n     */\n    select (feature) {\n      feature = this.resolveFeature(feature)\n      if (!feature) return\n\n      this.addFeature(feature)\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {void}\n     */\n    unselect (feature) {\n      feature = this.resolveFeature(feature)\n      if (!feature) return\n\n      this.removeFeature(feature)\n    },\n    /**\n     * Removes all features from selection.\n     * @return {void}\n     */\n    unselectAll () {\n      this.clearFeatures()\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRecreate()\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::interaction.methods.subscribeAll()\n      this::subscribeToInteractionChanges()\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {Feature}\n     */\n    resolveFeature (feature) {\n      hasMap(this)\n\n      if (feature instanceof Vue) {\n        feature = feature.$feature\n      }\n\n      if (feature instanceof Feature) {\n        return feature\n      }\n\n      const featureId = getFeatureId(feature)\n      if (!featureId) {\n        throw new Error('Undefined feature id')\n      }\n\n      feature = undefined\n      forEach(this.$map.getLayers().getArray(), layer => {\n        if (this.layerFilter && !this.layerFilter(layer)) {\n          return\n        }\n\n        const source = layer.getSource()\n        if (source && isFunction(source.getFeatureById)) {\n          feature = source.getFeatureById(featureId)\n        }\n\n        return !feature\n      })\n\n      return feature\n    },\n  },\n  watch: {\n    initializedFeature: {\n      deep: true,\n      handler (features) {\n        if (!this.$interaction || isEqual(features, this.featuresDataProj)) return\n        // select new features\n        features.forEach(::this.select)\n        // unselect non-matched features\n        difference(\n          this.getFeatures(),\n          features,\n          (a, b) => getFeatureId(a) === getFeatureId(b),\n        ).forEach(::this.unselect)\n      },\n    },\n    featuresDataProj: {\n      deep: true,\n      handler: debounce(function (features) {\n        this.$emit('update:features', features.slice())\n      }, 1000 / 60),\n    },\n    ...makeWatchers([\n      'filter',\n      'hitTolerance',\n      'multi',\n      'wrapX',\n      'addCondition',\n      'condition',\n      'removeCondition',\n      'toggleCondition',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const select = observableFromOlEvent(this.$featuresCollection, 'add')\n    .pipe(\n      mapOp(({ element }) => ({ type: 'select', feature: element })),\n    )\n  const unselect = observableFromOlEvent(this.$featuresCollection, 'remove')\n    .pipe(\n      mapOp(({ element }) => ({ type: 'unselect', feature: element })),\n    )\n  const events = mergeObs(select, unselect)\n\n  this.subscribeTo(events, evt => {\n    ++this.rev\n\n    this.$nextTick(() => {\n      this.$emit(evt.type, evt.feature)\n    })\n  })\n}\n","<template>\n  <i :id=\"vmId\" :class=\"cmpName\" style=\"display: none !important;\">\n    <slot :features=\"featuresDataProj\" />\n  </i>\n</template>\n\n<script>\n  import debounce from 'debounce-promise'\n  import { never, shiftKeyOnly, singleClick } from 'ol/events/condition'\n  import Feature from 'ol/Feature'\n  import SelectInteraction from 'ol/interaction/Select'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { map as mapOp } from 'rxjs/operators'\n  import Vue from 'vue'\n  import { featuresContainer, interaction, projTransforms, stylesContainer } from '../../mixin'\n  import { createStyle, defaultEditStyle, getFeatureId, getLayerId, initializeFeature } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasInteraction, hasMap } from '../../util/assert'\n  import { constant, difference, forEach, isEqual, isFunction, mapValues, stubArray } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  export default {\n    name: 'vl-interaction-select',\n    mixins: [interaction, featuresContainer, stylesContainer, projTransforms],\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          id: this.vmId,\n          class: this.cmpName,\n        }\n      },\n    },\n    props: {\n      /**\n       * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.\n       * @type {function|undefined}\n       */\n      filter: {\n        type: Function,\n        default: constant(true),\n      },\n      /**\n       * A list of layers from which features should be selected. Alternatively, a filter function can be provided.\n       * @type {string[]|function|undefined}\n       */\n      layers: {\n        type: [Array, Function],\n        default: undefined,\n      },\n      /**\n       * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.\n       * This only works for the canvas renderer and not for WebGL.\n       * @type {number}\n       */\n      hitTolerance: {\n        type: Number,\n        default: 0,\n      },\n      /**\n       * A boolean that determines if the default behaviour should select only single features or all (overlapping)\n       * features at the clicked map position.\n       * @type {boolean}\n       */\n      multi: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * Selected features as array of GeoJSON features with coordinates in the map view projection.\n       * @type {string[]|number[]|Object[]}\n       */\n      features: {\n        type: Array,\n        default: stubArray,\n      },\n      /**\n       * Wrap the world horizontally on the selection overlay.\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: true,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should\n       * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events\n       * for `add` and `remove` instead of `toggle`.\n       * @type {function|undefined}\n       */\n      addCondition: {\n        type: Function,\n        default: never,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.\n       * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature\n       * removes all from the selection.\n       * @type {function|undefined}\n       */\n      condition: {\n        type: Function,\n        default: singleClick,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`\n       * instead of `toggle`.\n       * @type {function|undefined}\n       */\n      removeCondition: {\n        type: Function,\n        default: never,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`\n       * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,\n       * and removes it if it is.\n       * @type {function|undefined}\n       */\n      toggleCondition: {\n        type: Function,\n        default: shiftKeyOnly,\n      },\n    },\n    computed: {\n      initializedFeature () {\n        return this.features.map(feature => initializeFeature({ ...feature }))\n      },\n      layerFilter () {\n        return Array.isArray(this.layers)\n          ? layer => this.layers.includes(getLayerId(layer))\n          : this.layers\n      },\n    },\n    methods: {\n      /**\n       * @return {Select}\n       * @protected\n       */\n      createInteraction () {\n        return new SelectInteraction({\n          features: this.$featuresCollection,\n          multi: this.multi,\n          wrapX: this.wrapX,\n          filter: this.filter,\n          layers: this.layerFilter,\n          hitTolerance: this.hitTolerance,\n          style: this.createStyleFunc(),\n          addCondition: this.addCondition,\n          condition: this.condition,\n          removeCondition: this.removeCondition,\n          toggleCondition: this.toggleCondition,\n        })\n      },\n      /**\n       * @return {function(feature: Feature): Style}\n       * @protected\n       */\n      getDefaultStyles () {\n        const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n        return function __selectDefaultStyleFunc (feature) {\n          if (feature.getGeometry()) {\n            return defaultStyles[feature.getGeometry().getType()]\n          }\n        }\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        return mergeDescriptors(\n          this::interaction.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n        )\n      },\n      /**\n       * @return {Interaction|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$interaction\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::interaction.methods.mount()\n        this.features.forEach(this.select)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.unselectAll()\n        this::interaction.methods.unmount()\n      },\n      /**\n       * @param {Object|Vue|Feature|string|number} feature\n       * @return {void}\n       * @throws {Error}\n       */\n      select (feature) {\n        feature = this.resolveFeature(feature)\n        if (!feature) return\n\n        this.addFeature(feature)\n      },\n      /**\n       * @param {Object|Vue|Feature|string|number} feature\n       * @return {void}\n       */\n      unselect (feature) {\n        feature = this.resolveFeature(feature)\n        if (!feature) return\n\n        this.removeFeature(feature)\n      },\n      /**\n       * Removes all features from selection.\n       * @return {void}\n       */\n      unselectAll () {\n        this.clearFeatures()\n      },\n      /**\n       * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n       * @return {void}\n       * @protected\n       */\n      setStyle (styles) {\n        if (styles !== this._styles) {\n          this._styles = styles\n          this.scheduleRecreate()\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::interaction.methods.subscribeAll()\n        this::subscribeToInteractionChanges()\n      },\n      /**\n       * @param {Object|Vue|Feature|string|number} feature\n       * @return {Feature}\n       */\n      resolveFeature (feature) {\n        hasMap(this)\n\n        if (feature instanceof Vue) {\n          feature = feature.$feature\n        }\n\n        if (feature instanceof Feature) {\n          return feature\n        }\n\n        const featureId = getFeatureId(feature)\n        if (!featureId) {\n          throw new Error('Undefined feature id')\n        }\n\n        feature = undefined\n        forEach(this.$map.getLayers().getArray(), layer => {\n          if (this.layerFilter && !this.layerFilter(layer)) {\n            return\n          }\n\n          const source = layer.getSource()\n          if (source && isFunction(source.getFeatureById)) {\n            feature = source.getFeatureById(featureId)\n          }\n\n          return !feature\n        })\n\n        return feature\n      },\n    },\n    watch: {\n      initializedFeature: {\n        deep: true,\n        handler (features) {\n          if (!this.$interaction || isEqual(features, this.featuresDataProj)) return\n          // select new features\n          features.forEach(::this.select)\n          // unselect non-matched features\n          difference(\n            this.getFeatures(),\n            features,\n            (a, b) => getFeatureId(a) === getFeatureId(b),\n          ).forEach(::this.unselect)\n        },\n      },\n      featuresDataProj: {\n        deep: true,\n        handler: debounce(function (features) {\n          this.$emit('update:features', features.slice())\n        }, 1000 / 60),\n      },\n      ...makeWatchers([\n        'filter',\n        'hitTolerance',\n        'multi',\n        'wrapX',\n        'addCondition',\n        'condition',\n        'removeCondition',\n        'toggleCondition',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const select = observableFromOlEvent(this.$featuresCollection, 'add')\n      .pipe(\n        mapOp(({ element }) => ({ type: 'select', feature: element })),\n      )\n    const unselect = observableFromOlEvent(this.$featuresCollection, 'remove')\n      .pipe(\n        mapOp(({ element }) => ({ type: 'unselect', feature: element })),\n      )\n    const events = mergeObs(select, unselect)\n\n    this.subscribeTo(events, evt => {\n      ++this.rev\n\n      this.$nextTick(() => {\n        this.$emit(evt.type, evt.feature)\n      })\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["name","mixins","interaction","featuresContainer","stylesContainer","projTransforms","stubVNode","empty","attrs","id","vmId","class","cmpName","props","filter","type","Function","default","constant","layers","Array","undefined","hitTolerance","Number","multi","Boolean","features","stubArray","wrapX","addCondition","never","condition","singleClick","removeCondition","toggleCondition","shiftKeyOnly","computed","initializedFeature","feature","initializeFeature","layerFilter","layer","getLayerId","methods","createInteraction","SelectInteraction","$featuresCollection","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","createStyle","__selectDefaultStyleFunc","getGeometry","getType","getServices","mergeDescriptors","getStyleTarget","$interaction","mount","select","unmount","unselectAll","resolveFeature","addFeature","unselect","removeFeature","clearFeatures","setStyle","_styles","scheduleRecreate","subscribeAll","subscribeToInteractionChanges","hasMap","Vue","$feature","Feature","featureId","getFeatureId","Error","forEach","$map","getLayers","getArray","source","getSource","isFunction","getFeatureById","watch","deep","handler","isEqual","featuresDataProj","difference","getFeatures","a","b","debounce","$emit","makeWatchers","hasInteraction","observableFromOlEvent","pipe","mapOp","element","events","mergeObs","subscribeTo","evt","rev","$nextTick","plugin","options","installed","pick","Interaction","component"],"mappings":"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"}