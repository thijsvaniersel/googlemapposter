{"version":3,"file":"index.js","sources":["src/component/vector-source/source.vue?rollup-plugin-vue=script.js","src/component/vector-source/source.vue","src/component/vector-source/index.js"],"sourcesContent":["\nimport VectorSource from 'ol/source/Vector'\nimport { vectorSource } from '../../mixin'\nimport { createGeoJsonFmt, getFeatureId, initializeFeature, loadingAll, transform } from '../../ol-ext'\nimport { constant, difference, isEqual, isFinite, isFunction, stubArray, isArray, isString } from '../../util/minilo'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nexport default {\n  name: 'vl-source-vector',\n  mixins: [vectorSource],\n  props: {\n    /**\n     * Array of GeoJSON features with coordinates in the map view projection.\n     * @type {Object[]} features\n     */\n    features: {\n      type: Array,\n      default: stubArray,\n    },\n    /**\n     * Source loader factory.\n     * Source loader should load features from some remote service, decode them and pas to `features` prop to render.\n     * @type {(function(): FeatureLoader|undefined)} loaderFactory\n     */\n    loaderFactory: {\n      type: Function,\n    },\n    /**\n     * Source format factory\n     * @type {(function(): Feature|undefined)} formatFactory\n     */\n    formatFactory: {\n      type: Function,\n      default: defaultFormatFactory,\n    },\n    /**\n     * String or url factory\n     * @type {(string|function(): string|FeatureUrlFunction|undefined)} url\n     */\n    url: [String, Function],\n    /**\n     * Loading strategy factory.\n     * Extent here in map view projection.\n     * @type {(function(): LoadingStrategy|undefined)} strategyFactory\n     */\n    strategyFactory: {\n      type: Function,\n      default: defaultStrategyFactory,\n    },\n    overlaps: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  computed: {\n    initializedFeatures () {\n      return this.features.map(feature => initializeFeature({ ...feature }))\n    },\n    urlFunc () {\n      if (!this.url) return\n\n      let url = this.url\n      if (!isFunction(url)) {\n        url = constant(this.url)\n      }\n\n      return (extent, resolution, projection) => {\n        extent = transformExtent(extent, projection, this.resolvedDataProjection)\n        projection = this.resolvedDataProjection\n\n        return url(extent, resolution, projection)\n      }\n    },\n    loaderFunc () {\n      if (!this.loaderFactory) return\n\n      const loader = this.loaderFactory()\n\n      return async (extent, resolution, projection) => {\n        let features = await loader(\n          transformExtent(extent, projection, this.resolvedDataProjection),\n          resolution,\n          this.resolvedDataProjection,\n        )\n        if (isString(features) && features !== '') {\n          features = this.readSourceData(features)\n        }\n        if (isArray(features)) {\n          this.addFeatures(features)\n        }\n      }\n    },\n    loadingStrategy () {\n      return this.strategyFactory()\n    },\n    dataFormatIdent () {\n      if (!this.olObjIdent) return\n\n      return this.makeIdent(this.olObjIdent, 'data_format')\n    },\n    dataFormat () {\n      return this.instanceFactoryCall(this.dataFormatIdent, ::this.formatFactory)\n    },\n  },\n  methods: {\n    /**\n     * @return {VectorSource}\n     * @protected\n     */\n    createSource () {\n      return new VectorSource({\n        attributions: this.attributions,\n        features: this.$featuresCollection,\n        projection: this.resolvedDataProjection,\n        loader: this.loaderFunc,\n        useSpatialIndex: this.useSpatialIndex,\n        wrapX: this.wrapX,\n        logo: this.logo,\n        strategy: this.loadingStrategy,\n        format: this.dataFormat,\n        url: this.urlFunc,\n        overlaps: this.overlaps,\n      })\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::vectorSource.methods.mount()\n      this.addFeatures(this.features)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.clear()\n      this::vectorSource.methods.unmount()\n    },\n    /**\n     * @param {mixed} data\n     * @returns {Array<FeatureLike>|Array<Feature>}\n     */\n    readSourceData (data) {\n      return this.dataFormat.readFeatures(data, {\n        featureProjection: this.viewProjection,\n        dataProjection: this.resolvedDataProjection,\n      })\n    },\n  },\n  watch: {\n    initializedFeatures: {\n      deep: true,\n      handler (features) {\n        if (!this.$source || isEqual(features, this.featuresDataProj)) return\n        // add new features\n        this.addFeatures(features)\n        // remove non-matched features\n        this.removeFeatures(difference(\n          this.getFeatures(),\n          features,\n          (a, b) => getFeatureId(a) === getFeatureId(b)\n        ))\n      },\n    },\n    ...makeWatchers([\n      'loadingStrategy',\n      'dataFormat',\n      'urlFunc',\n      'loaderFactory',\n      'formatFactory',\n      'strategyFactory',\n      'overlaps',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @return {LoadingStrategy}\n */\nfunction defaultStrategyFactory () {\n  return loadingAll\n}\n\n/**\n * @return {GeoJSON}\n */\nfunction defaultFormatFactory () {\n  return createGeoJsonFmt()\n}\n\nfunction transformExtent (extent, sourceProj, destProj) {\n  extent = extent.slice()\n  if (isFinite(extent[0]) && isFinite(extent[1])) {\n    [extent[0], extent[1]] = transform([extent[0], extent[1]], sourceProj, destProj)\n  }\n  if (isFinite(extent[2]) && isFinite(extent[3])) {\n    [extent[2], extent[3]] = transform([extent[2], extent[3]], sourceProj, destProj)\n  }\n  return extent\n}\n","<script>\n  import VectorSource from 'ol/source/Vector'\n  import { vectorSource } from '../../mixin'\n  import { createGeoJsonFmt, getFeatureId, initializeFeature, loadingAll, transform } from '../../ol-ext'\n  import { constant, difference, isEqual, isFinite, isFunction, stubArray, isArray, isString } from '../../util/minilo'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  export default {\n    name: 'vl-source-vector',\n    mixins: [vectorSource],\n    props: {\n      /**\n       * Array of GeoJSON features with coordinates in the map view projection.\n       * @type {Object[]} features\n       */\n      features: {\n        type: Array,\n        default: stubArray,\n      },\n      /**\n       * Source loader factory.\n       * Source loader should load features from some remote service, decode them and pas to `features` prop to render.\n       * @type {(function(): FeatureLoader|undefined)} loaderFactory\n       */\n      loaderFactory: {\n        type: Function,\n      },\n      /**\n       * Source format factory\n       * @type {(function(): Feature|undefined)} formatFactory\n       */\n      formatFactory: {\n        type: Function,\n        default: defaultFormatFactory,\n      },\n      /**\n       * String or url factory\n       * @type {(string|function(): string|FeatureUrlFunction|undefined)} url\n       */\n      url: [String, Function],\n      /**\n       * Loading strategy factory.\n       * Extent here in map view projection.\n       * @type {(function(): LoadingStrategy|undefined)} strategyFactory\n       */\n      strategyFactory: {\n        type: Function,\n        default: defaultStrategyFactory,\n      },\n      overlaps: {\n        type: Boolean,\n        default: true,\n      },\n    },\n    computed: {\n      initializedFeatures () {\n        return this.features.map(feature => initializeFeature({ ...feature }))\n      },\n      urlFunc () {\n        if (!this.url) return\n\n        let url = this.url\n        if (!isFunction(url)) {\n          url = constant(this.url)\n        }\n\n        return (extent, resolution, projection) => {\n          extent = transformExtent(extent, projection, this.resolvedDataProjection)\n          projection = this.resolvedDataProjection\n\n          return url(extent, resolution, projection)\n        }\n      },\n      loaderFunc () {\n        if (!this.loaderFactory) return\n\n        const loader = this.loaderFactory()\n\n        return async (extent, resolution, projection) => {\n          let features = await loader(\n            transformExtent(extent, projection, this.resolvedDataProjection),\n            resolution,\n            this.resolvedDataProjection,\n          )\n          if (isString(features) && features !== '') {\n            features = this.readSourceData(features)\n          }\n          if (isArray(features)) {\n            this.addFeatures(features)\n          }\n        }\n      },\n      loadingStrategy () {\n        return this.strategyFactory()\n      },\n      dataFormatIdent () {\n        if (!this.olObjIdent) return\n\n        return this.makeIdent(this.olObjIdent, 'data_format')\n      },\n      dataFormat () {\n        return this.instanceFactoryCall(this.dataFormatIdent, ::this.formatFactory)\n      },\n    },\n    methods: {\n      /**\n       * @return {VectorSource}\n       * @protected\n       */\n      createSource () {\n        return new VectorSource({\n          attributions: this.attributions,\n          features: this.$featuresCollection,\n          projection: this.resolvedDataProjection,\n          loader: this.loaderFunc,\n          useSpatialIndex: this.useSpatialIndex,\n          wrapX: this.wrapX,\n          logo: this.logo,\n          strategy: this.loadingStrategy,\n          format: this.dataFormat,\n          url: this.urlFunc,\n          overlaps: this.overlaps,\n        })\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::vectorSource.methods.mount()\n        this.addFeatures(this.features)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.clear()\n        this::vectorSource.methods.unmount()\n      },\n      /**\n       * @param {mixed} data\n       * @returns {Array<FeatureLike>|Array<Feature>}\n       */\n      readSourceData (data) {\n        return this.dataFormat.readFeatures(data, {\n          featureProjection: this.viewProjection,\n          dataProjection: this.resolvedDataProjection,\n        })\n      },\n    },\n    watch: {\n      initializedFeatures: {\n        deep: true,\n        handler (features) {\n          if (!this.$source || isEqual(features, this.featuresDataProj)) return\n          // add new features\n          this.addFeatures(features)\n          // remove non-matched features\n          this.removeFeatures(difference(\n            this.getFeatures(),\n            features,\n            (a, b) => getFeatureId(a) === getFeatureId(b)\n          ))\n        },\n      },\n      ...makeWatchers([\n        'loadingStrategy',\n        'dataFormat',\n        'urlFunc',\n        'loaderFactory',\n        'formatFactory',\n        'strategyFactory',\n        'overlaps',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @return {LoadingStrategy}\n   */\n  function defaultStrategyFactory () {\n    return loadingAll\n  }\n\n  /**\n   * @return {GeoJSON}\n   */\n  function defaultFormatFactory () {\n    return createGeoJsonFmt()\n  }\n\n  function transformExtent (extent, sourceProj, destProj) {\n    extent = extent.slice()\n    if (isFinite(extent[0]) && isFinite(extent[1])) {\n      [extent[0], extent[1]] = transform([extent[0], extent[1]], sourceProj, destProj)\n    }\n    if (isFinite(extent[2]) && isFinite(extent[3])) {\n      [extent[2], extent[3]] = transform([extent[2], extent[3]], sourceProj, destProj)\n    }\n    return extent\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Source from './source.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Source, options)\n\n  Vue.component(Source.name, Source)\n}\n\nexport default plugin\n\nexport {\n  Source,\n  plugin as install,\n}\n"],"names":["name","mixins","vectorSource","props","features","type","Array","default","stubArray","loaderFactory","Function","formatFactory","defaultFormatFactory","url","String","strategyFactory","defaultStrategyFactory","overlaps","Boolean","computed","initializedFeatures","feature","initializeFeature","urlFunc","isFunction","constant","extent","resolution","projection","transformExtent","resolvedDataProjection","loaderFunc","loader","isString","readSourceData","isArray","addFeatures","loadingStrategy","dataFormatIdent","olObjIdent","makeIdent","dataFormat","instanceFactoryCall","methods","createSource","VectorSource","attributions","$featuresCollection","useSpatialIndex","wrapX","logo","strategy","format","mount","unmount","clear","data","readFeatures","featureProjection","viewProjection","dataProjection","watch","deep","handler","$source","isEqual","featuresDataProj","removeFeatures","difference","getFeatures","a","b","getFeatureId","makeWatchers","scheduleRecreate","loadingAll","createGeoJsonFmt","sourceProj","destProj","isFinite","transform","plugin","Vue","options","installed","pick","Source","component"],"mappings":"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"}