/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.27
 * @license MIT
 * @copyright (c) 2017-2020, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _Object$assign from '@babel/runtime-corejs3/core-js-stable/object/assign';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _includesInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/includes';
import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Array$isArray from '@babel/runtime-corejs3/core-js-stable/array/is-array';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import Circle from 'ol/style/Circle';
import Fill from 'ol/style/Fill';
import Icon from 'ol/style/Icon';
import ImageStyle from 'ol/style/Image';
import RegularShape from 'ol/style/RegularShape';
import Stroke from 'ol/style/Stroke';
import Style from 'ol/style/Style';
import Text from 'ol/style/Text';
import parseColor from 'parse-color';
import uuid from 'uuid/v4';
import Vue from 'vue';
import { isFunction, isNumeric, isNumber, lowerFirst, pick, reduce, upperFirst } from '../util/minilo';
import { GEOMETRY_TYPE } from './consts';
import * as geomHelper from './geom';

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context7; _forEachInstanceProperty(_context7 = ownKeys(Object(source), true)).call(_context7, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context8; _forEachInstanceProperty(_context8 = ownKeys(Object(source))).call(_context8, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }
function getStyleId(style) {
  if (style instanceof Vue || style instanceof Style || style instanceof ImageStyle || style instanceof Text || style instanceof Stroke || style instanceof Fill || style instanceof Function) {
    return style.id;
  }

  throw new Error('Illegal style argument');
}
function setStyleId(style, styleId) {
  if (style instanceof Vue || style instanceof Style || style instanceof ImageStyle || style instanceof Text || style instanceof Stroke || style instanceof Fill || style instanceof Function) {
    style.id = styleId;
    return style;
  }

  throw new Error('Illegal style argument');
}
function initializeStyle(style, defaultStyleId) {
  if (getStyleId(style) == null) {
    setStyleId(style, defaultStyleId || uuid());
  }

  return style;
}
/**
 * @return {VlStyle[]}
 */

function defaultStyle() {
  return [{
    fillColor: [255, 255, 255, 0.4],
    strokeColor: '#3399cc',
    strokeWidth: 1.25,
    imageRadius: 5
  }];
}
/**
 * @return {Object<GEOMETRY_TYPE, VlStyle[]>}
 */

function defaultEditStyle() {
  var _context, _context2, _context3;

  /** @type {Object<GEOMETRY_TYPE, VlStyle[]>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[GEOMETRY_TYPE.LINE_STRING] = [{
    strokeColor: white,
    strokeWidth: width + 2
  }, {
    strokeColor: blue,
    strokeWidth: width
  }];
  styles[GEOMETRY_TYPE.MULTI_LINE_STRING] = styles[GEOMETRY_TYPE.LINE_STRING];
  styles[GEOMETRY_TYPE.POLYGON] = _concatInstanceProperty(_context = [{
    fillColor: [255, 255, 255, 0.5]
  }]).call(_context, styles[GEOMETRY_TYPE.LINE_STRING]);
  styles[GEOMETRY_TYPE.MULTI_POLYGON] = styles[GEOMETRY_TYPE.POLYGON];
  styles[GEOMETRY_TYPE.CIRCLE] = _concatInstanceProperty(_context2 = styles[GEOMETRY_TYPE.POLYGON]).call(_context2, styles[GEOMETRY_TYPE.LINE_STRING]);
  styles[GEOMETRY_TYPE.POINT] = [{
    imageRadius: width * 2,
    fillColor: blue,
    strokeColor: white,
    strokeWidth: width / 2,
    zIndex: Infinity
  }];
  styles[GEOMETRY_TYPE.MULTI_POINT] = styles[GEOMETRY_TYPE.POINT];
  styles[GEOMETRY_TYPE.GEOMETRY_COLLECTION] = _concatInstanceProperty(_context3 = styles[GEOMETRY_TYPE.POLYGON]).call(_context3, styles[GEOMETRY_TYPE.LINE_STRING], styles[GEOMETRY_TYPE.POINT]);
  return styles;
}

var isEmpty = function isEmpty(x) {
  if (x == null) return true;
  if (typeof x === 'number') return false;
  return (typeof x === 'string' || _Array$isArray(x)) && !x.length || !_Object$keys(x).length;
};
/**
 * @param {VlStyle} vlStyle
 * @return {Style|undefined}
 */


function createStyle(vlStyle) {
  if (isEmpty(vlStyle)) return;
  var olStyle = {
    text: createTextStyle(vlStyle),
    fill: createFillStyle(vlStyle),
    stroke: createStrokeStyle(vlStyle),
    image: createImageStyle(vlStyle),
    geometry: createGeomStyle(vlStyle),
    zIndex: vlStyle.zIndex,
    renderer: vlStyle.renderer
  };

  if (!isEmpty(olStyle)) {
    return new Style(olStyle);
  }
}

var addPrefix = function addPrefix(prefix) {
  return function (str) {
    return prefix + (prefix ? upperFirst(str) : str);
  };
};
/**
 * @param {*} color
 * @returns {*}
 */


function normalizeColor(color) {
  var c = color;

  if (typeof color === 'string') {
    c = parseColor(color).rgba;
  }

  return c;
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Fill|undefined}
 */

function createFillStyle(vlStyle) {
  var _context4;

  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var prefixKey = addPrefix(prefix);

  var keys = _mapInstanceProperty(_context4 = ['fillColor']).call(_context4, prefixKey);

  var compiledKey = prefixKey('fill'); // check on already compiled style existence

  if (vlStyle[compiledKey] instanceof Fill) return vlStyle[compiledKey];
  var fillStyle = reduce(vlStyle, function (style, value, name) {
    if (_includesInstanceProperty(keys).call(keys, name) === false) {
      return style;
    }

    name = lowerFirst(name.replace(new RegExp(prefixKey('fill')), ''));

    if (name === 'color') {
      value = normalizeColor(value);
    }

    style[name] = value;
    return style;
  }, {});

  if (!isEmpty(fillStyle)) {
    return new Fill(fillStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Stroke|undefined}
 */

function createStrokeStyle(vlStyle) {
  var _context5;

  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var prefixKey = addPrefix(prefix);

  var keys = _mapInstanceProperty(_context5 = ['strokeColor', 'strokeWidth', 'strokeMiterLimit', 'strokeCap', 'strokeJoin', 'strokeDash', 'strokeDashOffset']).call(_context5, prefixKey);

  var compiledKey = prefixKey('stroke');
  if (vlStyle[compiledKey] instanceof Stroke) return vlStyle[compiledKey];
  var strokeStyle = reduce(vlStyle, function (style, value, name) {
    if (_includesInstanceProperty(keys).call(keys, name) === false) {
      return style;
    }

    switch (name) {
      case prefixKey('strokeColor'):
      case prefixKey('strokeWidth'):
      case prefixKey('strokeMiterLimit'):
        name = lowerFirst(name.replace(new RegExp(prefixKey('stroke')), ''));
        break;

      case prefixKey('strokeCap'):
      case prefixKey('strokeJoin'):
      case prefixKey('strokeDash'):
      case prefixKey('strokeDashOffset'):
        name = 'line' + name.replace(new RegExp(prefixKey('stroke')), '');
        break;
    }

    if (name === 'color') {
      value = normalizeColor(value);
    }

    style[name] = value;
    return style;
  }, {});

  if (!isEmpty(strokeStyle)) {
    return new Stroke(strokeStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @returns {Image|undefined}
 * @todo split to separate circle, regShape, Icon
 */

function createImageStyle(vlStyle) {
  if (isEmpty(vlStyle.imageSrc) && isEmpty(vlStyle.image) && isEmpty(vlStyle.imagePoints) && !isNumeric(vlStyle.imageRadius)) {
    return;
  }

  if (vlStyle.image instanceof ImageStyle) return vlStyle.image;
  var imageStyle, Ctor;

  if (!isEmpty(vlStyle.imageSrc) || !isEmpty(vlStyle.image)) {
    // icon construction
    Ctor = Icon; // then create Icon options

    imageStyle = _objectSpread(_objectSpread({}, vlStyle), {}, {
      anchor: vlStyle.imageAnchor,
      anchorOrigin: vlStyle.imageAnchorOrigin,
      color: vlStyle.imageColor,
      offset: vlStyle.imageOffset,
      offsetOrigin: vlStyle.imageOffsetOrigin,
      opacity: vlStyle.imageOpacity,
      scale: vlStyle.imageScale,
      rotation: vlStyle.imageRotation,
      size: vlStyle.imageSize,
      img: vlStyle.image,
      imgSize: vlStyle.imageImgSize,
      src: vlStyle.imageSrc,
      crossOrigin: vlStyle.imageCrossOrigin
    });
  } else if (vlStyle.imagePoints != null) {
    // regular shape construction
    Ctor = RegularShape; // create RegularShape options

    imageStyle = _objectSpread(_objectSpread({}, vlStyle), {}, {
      points: vlStyle.imagePoints,
      radius: vlStyle.imageRadius,
      radius1: vlStyle.imageRadius1,
      radius2: vlStyle.imageRadius2,
      angle: vlStyle.imageAngle,
      rotation: vlStyle.imageRotation
    });
  } else {
    // circle construction
    Ctor = Circle; // create Circle options

    imageStyle = _objectSpread(_objectSpread({}, vlStyle), {}, {
      radius: vlStyle.imageRadius
    });
  }

  imageStyle = _objectSpread(_objectSpread({}, imageStyle), {}, {
    fill: createFillStyle(vlStyle, 'image') || createFillStyle(vlStyle),
    stroke: createStrokeStyle(vlStyle, 'image') || createStrokeStyle(vlStyle),
    snapToPixel: true
  });

  if (!isEmpty(imageStyle)) {
    return new Ctor(imageStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @returns {Text|undefined}
 */

function createTextStyle(vlStyle) {
  var _context6;

  if (vlStyle.text == null) return;
  if (vlStyle.text instanceof Text) return vlStyle.text;
  var textStyle = {
    text: vlStyle.text
  };
  var fontSize = '10px';

  if (vlStyle.textFontSize) {
    fontSize = isNumber(vlStyle.textFontSize) ? vlStyle.textFontSize + 'px' : vlStyle.textFontSize;
  }

  var fontName = vlStyle.textFont || 'sans-serif';

  var font = _filterInstanceProperty(_context6 = [vlStyle.textFontWeight, fontSize, fontName]).call(_context6, function (x) {
    return !!x;
  }).join(' ');

  _Object$assign(textStyle, pick(vlStyle, ['textAlign', 'textBaseline']), {
    font: font,
    fill: createFillStyle(vlStyle, 'text') || createFillStyle(vlStyle),
    stroke: createStrokeStyle(vlStyle, 'text') || createStrokeStyle(vlStyle),
    scale: vlStyle.textScale,
    rotation: vlStyle.textRotation,
    offsetX: vlStyle.textOffsetX,
    offsetY: vlStyle.textOffsetY,
    rotateWithView: vlStyle.textRotateWithView,
    padding: vlStyle.textPadding,
    maxAngle: vlStyle.textMaxAngle,
    overflow: vlStyle.textOverflow,
    placement: vlStyle.textPlacement,
    backgroundFill: createFillStyle(vlStyle, 'textBackground'),
    backgroundStroke: createStrokeStyle(vlStyle, 'textBackground')
  });

  if (!isEmpty(textStyle)) {
    return new Text(textStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @return {Geometry|function|undefined}
 */

function createGeomStyle(vlStyle) {
  if (isFunction(vlStyle.geom)) {
    return function __styleGeomFunc(feature) {
      return vlStyle.geom(feature, geomHelper);
    };
  }

  return vlStyle.geom;
}
/**
 * @typedef {Style|Image|Fill|Stroke|Text|StyleFunction} OlStyle
 */

/**
 * @typedef {Object} VlStyle
 *
 * Shared
 * @property {string|number[]|undefined} fillColor
 * @property {string|number[]|undefined} strokeColor
 * @property {number|undefined} strokeWidth
 * @property {number|undefined} strokeMiterLimit
 * @property {number[]|undefined} strokeDash
 * @property {number[]|undefined} strokeDashOffset
 * @property {string|undefined} strokeCap
 * @property {string|undefined} strokeJoin
 * @property {number|undefined} zIndex
 * @property {Fill|undefined} fill
 * @property {Stroke|undefined} stroke
 * @property {RenderFunction|undefined} renderer
 *
 * Text only
 * @property {string|Text|undefined} text
 * @property {string|undefined} textFont
 * @property {number|string|undefined} textFontSize
 * @property {string|undefined} textFontWeight
 * @property {string|number[]|undefined} textFillColor
 * @property {string|number[]|undefined} textStrokeColor
 * @property {number|undefined} textStrokeWidth
 * @property {number[]|undefined} textStrokeDash
 * @property {string|undefined} textStrokeCap
 * @property {string|undefined} textStrokeJoin
 * @property {number|undefined} textScale
 * @property {string|undefined} textAlign
 * @property {number|undefined} textRotation
 * @property {number|undefined} textOffsetX
 * @property {number|undefined} textOffsetY
 * @property {Stroke|undefined} textStroke
 * @property {Fill|undefined} textFill
 * @property {boolean|undefined} textRotateWithView
 * @property {number[]|undefined} textPadding
 * @property {number|undefined} textMaxAngle
 * @property {boolean|undefined} textOverflow
 * @property {string|undefined} textPlacement
 * @property {string|undefined} textBaseline
 * @property {Fill|undefined} textBackgroundFillColor
 * @property {Stroke|undefined} textBackgroundStrokeColor
 * @property {Stroke|undefined} textBackgroundStrokeWidth
 * @property {Stroke|undefined} textBackgroundStrokeDash
 * @property {Stroke|undefined} textBackgroundStrokeCap
 * @property {Stroke|undefined} textBackgroundStrokeJoin
 *
 * Image only
 * @property {Image|undefined} image
 * @property {string|undefined} imageSrc
 * @property {number[]|undefined} imageSize
 * @property {number[]|undefined} imageImgSize
 * @property {number|undefined} imageOffset
 * @property {number[]|undefined} imageAnchor
 * @property {number|undefined} imageScale
 * @property {number|undefined} imageRotation
 * @property {number|undefined} imageRadius
 * @property {number|undefined} imageRadius1
 * @property {number|undefined} imageRadius2
 * @property {number|undefined} imagePoints
 * @property {number|undefined} imageAngle
 * @property {number|undefined} imageOpacity
 * @property {string|number[]|undefined} imageFillColor
 * @property {string|number[]|undefined} imageStrokeColor
 * @property {number|undefined} imageStrokeWidth
 * @property {number[]|undefined} imageStrokeDash
 * @property {string|undefined} imageStrokeCap
 * @property {string|undefined} imageStrokeJoin
 * @property {IconOrigin|undefined} imageAnchorOrigin
 * @property {ColorLike|undefined} imageColor
 * @property {IconOrigin|undefined} imageOffsetOrigin
 * @property {Stroke|undefined} imageStroke
 * @property {Fill|undefined} imageFill
 * @property {string|undefined} imageCrossOrigin
 *
 * @property {Geometry|function|undefined} geom Coordinates should be in map projection
 */

export { getStyleId, setStyleId, initializeStyle, defaultStyle, defaultEditStyle, createStyle, normalizeColor, createFillStyle, createStrokeStyle, createImageStyle, createTextStyle, createGeomStyle };
