/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.24
 * @license MIT
 * @copyright (c) 2017-2020, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import Feature from 'ol/Feature';
import uuid from 'uuid/v4';
import Vue from 'vue';
import { isNumber, isPlainObject, isString } from '../util/minilo';

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; _forEachInstanceProperty(_context = ownKeys(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context2; _forEachInstanceProperty(_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * @param {Object|Vue|Feature|string|number} feature
 * @return {string|number}
 * @throws {Error}
 */

function getFeatureId(feature) {
  if (isPlainObject(feature) || feature instanceof Vue) {
    return feature.id;
  } else if (feature instanceof Feature) {
    return feature.getId();
  } else if (isString(feature) || isNumber(feature)) {
    return feature;
  }

  throw new Error('Illegal feature format');
}
/**
 * @param {Feature|Vue|Object} feature
 * @param {string} featureId
 * @returns {Feature|Vue|Object}
 */

function setFeatureId(feature, featureId) {
  if (isPlainObject(feature) || feature instanceof Vue) {
    feature.id = featureId;
    return feature;
  } else if (feature instanceof Feature) {
    feature.setId(featureId);
    return feature;
  }

  throw new Error('Illegal feature format');
}
/**
 * @param {Feature} feature
 * @param {string|undefined} defaultFeatureId
 * @returns {Feature}
 */

function initializeFeature(feature, defaultFeatureId) {
  if (getFeatureId(feature) == null) {
    setFeatureId(feature, defaultFeatureId || uuid());
  }

  return feature;
}
/**
 * @param {Feature} destFeature
 * @param {Feature} srcFeature
 * @returns {Feature}
 */

function mergeFeatures(destFeature, srcFeature) {
  destFeature.setProperties(_objectSpread({}, srcFeature.getProperties()));
  destFeature.setGeometry(srcFeature.getGeometry().clone());
  destFeature.setStyle(srcFeature.getStyle() != null ? srcFeature.getStyle().clone() : undefined);
  return destFeature;
}

export { getFeatureId, setFeatureId, initializeFeature, mergeFeatures };
