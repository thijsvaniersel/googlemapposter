/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.24
 * @license MIT
 * @copyright (c) 2017-2020, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _bindInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/bind';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import Vue from 'vue';
import IdentityMap from '../util/identity-map';
import { identity, stubObject, keys } from '../util/minilo';

var INSTANCES_POOL = 'instances';
var identMap = {
  INSTANCES_POOL: INSTANCES_POOL,
  props: {
    /**
     * Unique key for saving to identity map
     * @type {string|number}
     * @experimental
     */
    ident: [String, Number]
  },
  data: function data() {
    return {
      idents: stubObject()
    };
  },
  computed: {
    selfIdent: function selfIdent() {
      return this.makeSelfIdent();
    }
  },
  watch: {
    ident: function ident(value, prev) {
      if (prev && this.$identityMap.has(prev)) {
        this.$identityMap.unset(prev);
      }

      if (value && !this.$identityMap.has(value)) {
        this.$identityMap.set(value);
      }
    }
  },
  beforeCreate: function beforeCreate() {
    initIdentityMap();
  },
  destroyed: function destroyed() {
    this.unsetInstances();
  },
  methods: {
    /**
     * @param parts
     * @return {string|undefined}
     * @protected
     */
    makeSelfIdent: function makeSelfIdent() {
      var _context;

      if (!this.ident) return;

      for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
        parts[_key] = arguments[_key];
      }

      return this.makeIdent.apply(this, _concatInstanceProperty(_context = [this.ident]).call(_context, parts));
    },

    /**
     * @param parts
     * @return {string}
     */
    makeIdent: function makeIdent() {
      for (var _len2 = arguments.length, parts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        parts[_key2] = arguments[_key2];
      }

      return _filterInstanceProperty(parts).call(parts, identity).join('.');
    },

    /**
     * Caches or reuse factory result in the identity map
     * and returns result.
     *
     * @param {string|undefined} ident
     * @param {function} factory
     * @returns {*}
     */
    instanceFactoryCall: function instanceFactoryCall(ident, factory) {
      if (ident && this.$identityMap.has(ident, INSTANCES_POOL)) {
        this.idents[ident] = true;
        return this.$identityMap.get(ident, INSTANCES_POOL);
      }

      var inst = factory();

      if (ident) {
        this.idents[ident] = true;
        this.$identityMap.set(ident, inst, INSTANCES_POOL);
      }

      return inst;
    },

    /**
     * @param {string|undefined} ident
     * @returns {*}
     */
    getInstance: function getInstance(ident) {
      if (!ident) return;
      if (!this.hasInstance(ident)) return;
      this.idents[ident] = true;
      return this.$identityMap.get(ident, INSTANCES_POOL);
    },

    /**
     * @param {string|undefined} ident
     * @returns {*}
     */
    hasInstance: function hasInstance(ident) {
      if (!ident) return false;
      return this.$identityMap.has(ident, INSTANCES_POOL);
    },

    /**
     * @param {string|undefined} ident
     */
    unsetInstance: function unsetInstance(ident) {
      if (!ident) return;
      delete this.idents[ident];
      this.$identityMap.unset(ident, INSTANCES_POOL);
    },

    /**
     * Unsets all self indets
     * @return {void}
     */
    unsetInstances: function unsetInstances() {
      var _context2, _context3;

      _forEachInstanceProperty(_context2 = keys(this.idents)).call(_context2, _bindInstanceProperty(_context3 = this.unsetInstance).call(_context3, this));
    }
  }
};

function initIdentityMap() {
  var imap = new IdentityMap();

  if (!('$identityMap' in Vue)) {
    _Object$defineProperties(Vue, {
      $identityMap: {
        enumerable: true,
        get: function get() {
          return imap;
        }
      }
    });
  }

  if (!('$identityMap' in Vue.prototype)) {
    _Object$defineProperties(Vue.prototype, {
      $identityMap: {
        enumerable: true,
        get: function get() {
          return imap;
        }
      }
    });
  }
}

export default identMap;
