{"version":3,"file":"index.js","sources":["src/component/style-func/style.vue?rollup-plugin-vue=script.js","src/component/style-func/style.vue","src/component/style-func/index.js"],"sourcesContent":["\nimport { Style } from 'ol/style'\nimport { style, stylesContainer } from '../../mixin'\nimport { hasMap } from '../../util/assert'\nimport { warn } from '../../util/log'\nimport { isFunction, noop } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\n\n/**\n * Style function component for advanced styling.\n * Plays the role of both a style that mounts itself to style target component (vl-layer-vector, vl-feature & etc.)\n * and style target for inner style containers (vl-style-box) as fallback style.\n */\nexport default {\n  name: 'vl-style-func',\n  mixins: [style, stylesContainer],\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        id: this.vmId,\n        class: this.cmpName,\n      }\n    },\n  },\n  props: {\n    /**\n     * @type {function(): function(feature: Feature): Style}\n     */\n    factory: {\n      type: Function,\n      required: true,\n    },\n  },\n  computed: {\n    styleFunc () {\n      let func = this.factory()\n      if (!isFunction(func)) {\n        if (process.env.NODE_ENV !== 'production') {\n          warn(`Factory returned a value not of Function type, fallback style will be used`)\n        }\n        func = noop\n      }\n\n      return func\n    },\n  },\n  methods: {\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    createStyle () {\n      hasMap(this)\n      // user provided style function\n      const providedStyleFunc = this.styleFunc\n      // fallback style function made from inner style containers\n      const fallbackStyleFunc = this.createStyleFunc()\n\n      return function __styleFunc (feature, resolution) {\n        const styles = providedStyleFunc(feature, resolution)\n        // not empty or null style\n        if (\n          styles === null ||\n          (Array.isArray(styles) && styles.length) ||\n          styles instanceof Style\n        ) {\n          return styles\n        }\n        return fallbackStyleFunc(feature, resolution)\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this.$stylesContainer && this.$stylesContainer.addStyle(this)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.$stylesContainer && this.$stylesContainer.removeStyle(this)\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      const vm = this\n\n      return mergeDescriptors(this::style.methods.getServices(), {\n        get stylesContainer () { return vm },\n      })\n    },\n    /**\n     * Overrides stylesContainer `setStyle` method\n     * @param {Array<{ style: Style, condition: (function|boolean|undefined) }>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        // simply save all inner styles and\n        // use them later in style function as fallback\n        this._styles = styles\n        this.scheduleRefresh()\n      }\n    },\n    /**\n     * @return {Promise}\n     */\n    refresh () {\n      // recreate style\n      return this.recreate()\n    },\n  },\n  watch: {\n    factory () {\n      this.scheduleRefresh()\n    },\n  },\n}\n","<script>\n  import { Style } from 'ol/style'\n  import { style, stylesContainer } from '../../mixin'\n  import { hasMap } from '../../util/assert'\n  import { warn } from '../../util/log'\n  import { isFunction, noop } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n\n  /**\n   * Style function component for advanced styling.\n   * Plays the role of both a style that mounts itself to style target component (vl-layer-vector, vl-feature & etc.)\n   * and style target for inner style containers (vl-style-box) as fallback style.\n   */\n  export default {\n    name: 'vl-style-func',\n    mixins: [style, stylesContainer],\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          id: this.vmId,\n          class: this.cmpName,\n        }\n      },\n    },\n    props: {\n      /**\n       * @type {function(): function(feature: Feature): Style}\n       */\n      factory: {\n        type: Function,\n        required: true,\n      },\n    },\n    computed: {\n      styleFunc () {\n        let func = this.factory()\n        if (!isFunction(func)) {\n          if (process.env.NODE_ENV !== 'production') {\n            warn(`Factory returned a value not of Function type, fallback style will be used`)\n          }\n          func = noop\n        }\n\n        return func\n      },\n    },\n    methods: {\n      /**\n       * @return {function(feature: Feature): Style}\n       * @protected\n       */\n      createStyle () {\n        hasMap(this)\n        // user provided style function\n        const providedStyleFunc = this.styleFunc\n        // fallback style function made from inner style containers\n        const fallbackStyleFunc = this.createStyleFunc()\n\n        return function __styleFunc (feature, resolution) {\n          const styles = providedStyleFunc(feature, resolution)\n          // not empty or null style\n          if (\n            styles === null ||\n            (Array.isArray(styles) && styles.length) ||\n            styles instanceof Style\n          ) {\n            return styles\n          }\n          return fallbackStyleFunc(feature, resolution)\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this.$stylesContainer && this.$stylesContainer.addStyle(this)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.$stylesContainer && this.$stylesContainer.removeStyle(this)\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        const vm = this\n\n        return mergeDescriptors(this::style.methods.getServices(), {\n          get stylesContainer () { return vm },\n        })\n      },\n      /**\n       * Overrides stylesContainer `setStyle` method\n       * @param {Array<{ style: Style, condition: (function|boolean|undefined) }>|function(feature: Feature): Style|Vue|undefined} styles\n       * @return {void}\n       */\n      setStyle (styles) {\n        if (styles !== this._styles) {\n          // simply save all inner styles and\n          // use them later in style function as fallback\n          this._styles = styles\n          this.scheduleRefresh()\n        }\n      },\n      /**\n       * @return {Promise}\n       */\n      refresh () {\n        // recreate style\n        return this.recreate()\n      },\n    },\n    watch: {\n      factory () {\n        this.scheduleRefresh()\n      },\n    },\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Style from './style.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Style, options)\n\n  Vue.component(Style.name, Style)\n}\n\nexport default plugin\n\nexport {\n  Style,\n  plugin as install,\n}\n"],"names":["name","mixins","style","stylesContainer","stubVNode","empty","attrs","id","vmId","class","cmpName","props","factory","type","Function","required","computed","styleFunc","func","isFunction","process","env","NODE_ENV","warn","noop","methods","createStyle","hasMap","providedStyleFunc","fallbackStyleFunc","createStyleFunc","__styleFunc","feature","resolution","styles","length","Style","mount","$stylesContainer","addStyle","unmount","removeStyle","getServices","vm","mergeDescriptors","setStyle","_styles","scheduleRefresh","refresh","recreate","watch","plugin","Vue","options","installed","pick","component"],"mappings":";;;;;;;;;;;;;;;;;;;;AAQA;;;;;;AAKA,aAAe;EACbA,IAAI,EAAE,eADO;EAEbC,MAAM,EAAE,CAACC,KAAD,EAAQC,eAAR,CAFK;EAGbC,SAAS,EAAE;IACTC,KAAK,EAAE,KADE;IAETC,KAFS,mBAEA;aACA;QACLC,EAAE,EAAE,KAAKC,IADJ;QAELC,KAAK,EAAE,KAAKC;OAFd;;GANS;EAYbC,KAAK,EAAE;;;;IAILC,OAAO,EAAE;MACPC,IAAI,EAAEC,QADC;MAEPC,QAAQ,EAAE;;GAlBD;EAqBbC,QAAQ,EAAE;IACRC,SADQ,uBACK;UACPC,IAAI,GAAG,KAAKN,OAAL,EAAX;;UACI,CAACO,UAAU,CAACD,IAAD,CAAf,EAAuB;YACjBE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;UACzCC,IAAI,8EAAJ;;;QAEFL,IAAI,GAAGM,IAAP;;;aAGKN,IAAP;;GA/BS;EAkCbO,OAAO,EAAE;;;;;IAKPC,WALO,yBAKQ;MACbC,MAAM,CAAC,IAAD,CAAN,CADa;;UAGPC,iBAAiB,GAAG,KAAKX,SAA/B,CAHa;;UAKPY,iBAAiB,GAAG,KAAKC,eAAL,EAA1B;aAEO,SAASC,WAAT,CAAsBC,OAAtB,EAA+BC,UAA/B,EAA2C;YAC1CC,MAAM,GAAGN,iBAAiB,CAACI,OAAD,EAAUC,UAAV,CAAhC,CADgD;;YAI9CC,MAAM,KAAK,IAAX,IACC,eAAcA,MAAd,KAAyBA,MAAM,CAACC,MADjC,IAEAD,MAAM,YAAYE,KAHpB,EAIE;iBACOF,MAAP;;;eAEKL,iBAAiB,CAACG,OAAD,EAAUC,UAAV,CAAxB;OAVF;KAZK;;;;;;IA6BPI,KA7BO,mBA6BE;WACFC,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBC,QAAtB,CAA+B,IAA/B,CAAzB;KA9BK;;;;;;IAoCPC,OApCO,qBAoCI;WACJF,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBG,WAAtB,CAAkC,IAAlC,CAAzB;KArCK;;;;;;IA2CPC,WA3CO,yBA2CQ;UACPC,EAAE,GAAG,IAAX;aAEOC,gBAAgB,CAAO1C,KAAK,CAACuB,OAAN,CAAciB,WAApB,WAAD,EAAoC;YACrDvC,eAAJ,GAAuB;iBAASwC,EAAP;;;OADJ,CAAvB;KA9CK;;;;;;;IAuDPE,QAvDO,oBAuDGX,MAvDH,EAuDW;UACZA,MAAM,KAAK,KAAKY,OAApB,EAA6B;;;aAGtBA,OAAL,GAAeZ,MAAf;aACKa,eAAL;;KA5DG;;;;;IAkEPC,OAlEO,qBAkEI;;aAEF,KAAKC,QAAL,EAAP;;GAtGS;EAyGbC,KAAK,EAAE;IACLtC,OADK,qBACM;WACJmC,eAAL;;;CA3GN;;ACVY,2BAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAZ,SAASI,MAAT,CAAiBC,GAAjB,EAAoC;MAAdC,OAAc,uEAAJ,EAAI;;MAC9BF,MAAM,CAACG,SAAX,EAAsB;;;;EAGtBH,MAAM,CAACG,SAAP,GAAmB,IAAnB;EAEAD,OAAO,GAAGE,IAAI,CAACF,OAAD,EAAU,gBAAV,CAAd;;iBACcjB,OAAd,EAAqBiB,OAArB;;EAEAD,GAAG,CAACI,SAAJ,CAAcpB,OAAK,CAACpC,IAApB,EAA0BoC,OAA1B;;;;;;"}