{"version":3,"file":"index.js","sources":["src/component/feature/feature.vue?rollup-plugin-vue=script.js","src/component/feature/feature.vue","src/component/feature/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport Feature from 'ol/Feature'\nimport { Observable } from 'rxjs'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilChanged, map as mapObs, mergeAll } from 'rxjs/operators'\nimport { geometryContainer, olCmp, projTransforms, stylesContainer, useMapCmp } from '../../mixin'\nimport { findPointOnSurface, getFeatureId, initializeFeature, setFeatureId } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasFeature, hasMap } from '../../util/assert'\nimport { isEqual, plainProps } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\n\n/**\n * A vector object for geographic features with a geometry and other attribute properties,\n * similar to the features in vector file formats like **GeoJSON**.\n */\nexport default {\n  name: 'vl-feature',\n  mixins: [olCmp, useMapCmp, geometryContainer, stylesContainer, projTransforms],\n  props: {\n    /**\n     * All feature properties.\n     * @type {Object}\n     * @default {}\n     */\n    properties: {\n      type: Object,\n      default: () => Object.create(null),\n    },\n  },\n  computed: {\n    /**\n     * **GeoJSON** encoded geometry.\n     * @type {Object|undefined}\n     */\n    geometry () {\n      if (this.rev && this.resolvedDataProjection && this.$geometry) {\n        return this.writeGeometryInDataProj(this.$geometry)\n      }\n    },\n    /**\n     * @return {number[]|undefined}\n     */\n    point () {\n      if (this.pointViewProj && this.resolvedDataProjection) {\n        return this.pointToDataProj(this.pointViewProj)\n      }\n    },\n    geometryViewProj () {\n      if (this.rev && this.resolvedDataProjection && this.$geometry) {\n        return this.writeGeometryInViewProj(this.$geometry)\n      }\n    },\n    pointViewProj () {\n      if (this.rev && this.$geometry) {\n        return findPointOnSurface(this.$geometry)\n      }\n    },\n  },\n  methods: {\n    /**\n     * Create feature without inner style applying, feature level style\n     * will be applied in the layer level style function.\n     * @return {module:ol/Feature~Feature}\n     * @protected\n     */\n    createOlObject () {\n      let feature = new Feature(this.properties)\n\n      initializeFeature(feature, this.id)\n      feature.setGeometry(this.$geometry)\n\n      return feature\n    },\n    /**\n     * @return {{\n     *     getGeometry: function(): (module:ol/geom/Geometry~Geometry|undefined),\n     *     setGeometry: function((module:ol/geom/Geometry~Geometry|undefined)): void\n     *   }|Feature|undefined}\n     * @protected\n     */\n    getGeometryTarget () {\n      return this.$feature\n    },\n    /**\n     * @return {Object}\n     * @protected\n     */\n    getServices () {\n      const vm = this\n\n      return mergeDescriptors(\n        this::olCmp.methods.getServices(),\n        this::geometryContainer.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n        {\n          get feature () { return vm.$feature },\n        },\n      )\n    },\n    /**\n     * @return {module:ol/Feature~Feature|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$feature\n    },\n    /**\n     * Checks if feature lies at `pixel`.\n     * @param {number[]} pixel\n     * @return {boolean}\n     */\n    isAtPixel (pixel) {\n      hasMap(this)\n\n      return this.$map.forEachFeatureAtPixel(\n        pixel,\n        f => f === this.$feature,\n        { layerFilter: l => l === this.$layer },\n      )\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this.$featuresContainer && this.$featuresContainer.addFeature(this)\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unsubscribeAll()\n      this.$featuresContainer && this.$featuresContainer.removeFeature(this)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToEvents()\n    },\n  },\n  watch: {\n    /**\n     * @param {string|number} value\n     */\n    id (value) {\n      if (this.$feature && value !== getFeatureId(this.$feature)) {\n        setFeatureId(this.$feature, value)\n      }\n    },\n    /**\n     * @param {Object} value\n     */\n    properties (value) {\n      value = plainProps(value)\n      if (this.$feature && !isEqual(value, plainProps(this.$feature.getProperties()))) {\n        this.$feature.setProperties(value)\n      }\n    },\n  },\n  created () {\n    this::defineServices()\n  },\n}\n\nfunction defineServices () {\n  Object.defineProperties(this, {\n    $feature: {\n      enumerable: true,\n      get: () => this.$olObject,\n    },\n    $geometry: {\n      enumerable: true,\n      get: this.getGeometry,\n    },\n    $layer: {\n      enumerable: true,\n      get: () => this.$services && this.$services.layer,\n    },\n    $map: {\n      enumerable: true,\n      get: () => this.$services && this.$services.map,\n    },\n    $view: {\n      enumerable: true,\n      get: () => this.$services && this.$services.view,\n    },\n    $featuresContainer: {\n      enumerable: true,\n      get: () => this.$services && this.$services.featuresContainer,\n    },\n  })\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToEvents () {\n  hasFeature(this)\n\n  const getPropValue = prop => this.$feature.get(prop)\n  // all plain properties + geometry\n  const propChanges = observableFromOlEvent(\n    this.$feature,\n    'propertychange',\n    ({ key }) => ({ prop: key, value: getPropValue(key) }),\n  )\n  // id, style and other generic changes\n  const changes = observableFromOlEvent(\n    this.$feature,\n    'change',\n  ).pipe(\n    mapObs(() => Observable.create(obs => {\n      if (this.$feature.getId() !== this.id) {\n        obs.next({ prop: 'id', value: this.$feature.getId() })\n      }\n      // todo style?\n    })),\n    mergeAll(),\n  )\n  // all changes\n  const allChanges = mergeObs(propChanges, changes).pipe(\n    distinctUntilChanged(isEqual),\n  )\n\n  this.subscribeTo(allChanges, ({ prop, value }) => {\n    ++this.rev\n\n    this.$nextTick(() => {\n      if (prop === 'id') {\n        this.$emit(`update:${prop}`, value)\n      } else if (prop !== this.$feature.getGeometryName()) {\n        this.$emit('update:properties', { ...this.properties, [prop]: value })\n      }\n    })\n  })\n}\n","<template>\n  <i :id=\"vmId\" :class=\"cmpName\" style=\"display: none !important;\">\n    <slot :id=\"id\" :properties=\"properties\" :geometry=\"geometry\" :point=\"point\" />\n  </i>\n</template>\n\n<script>\n  import Feature from 'ol/Feature'\n  import { Observable } from 'rxjs'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilChanged, map as mapObs, mergeAll } from 'rxjs/operators'\n  import { geometryContainer, olCmp, projTransforms, stylesContainer, useMapCmp } from '../../mixin'\n  import { findPointOnSurface, getFeatureId, initializeFeature, setFeatureId } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasFeature, hasMap } from '../../util/assert'\n  import { isEqual, plainProps } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n\n  /**\n   * A vector object for geographic features with a geometry and other attribute properties,\n   * similar to the features in vector file formats like **GeoJSON**.\n   */\n  export default {\n    name: 'vl-feature',\n    mixins: [olCmp, useMapCmp, geometryContainer, stylesContainer, projTransforms],\n    props: {\n      /**\n       * All feature properties.\n       * @type {Object}\n       * @default {}\n       */\n      properties: {\n        type: Object,\n        default: () => Object.create(null),\n      },\n    },\n    computed: {\n      /**\n       * **GeoJSON** encoded geometry.\n       * @type {Object|undefined}\n       */\n      geometry () {\n        if (this.rev && this.resolvedDataProjection && this.$geometry) {\n          return this.writeGeometryInDataProj(this.$geometry)\n        }\n      },\n      /**\n       * @return {number[]|undefined}\n       */\n      point () {\n        if (this.pointViewProj && this.resolvedDataProjection) {\n          return this.pointToDataProj(this.pointViewProj)\n        }\n      },\n      geometryViewProj () {\n        if (this.rev && this.resolvedDataProjection && this.$geometry) {\n          return this.writeGeometryInViewProj(this.$geometry)\n        }\n      },\n      pointViewProj () {\n        if (this.rev && this.$geometry) {\n          return findPointOnSurface(this.$geometry)\n        }\n      },\n    },\n    methods: {\n      /**\n       * Create feature without inner style applying, feature level style\n       * will be applied in the layer level style function.\n       * @return {module:ol/Feature~Feature}\n       * @protected\n       */\n      createOlObject () {\n        let feature = new Feature(this.properties)\n\n        initializeFeature(feature, this.id)\n        feature.setGeometry(this.$geometry)\n\n        return feature\n      },\n      /**\n       * @return {{\n       *     getGeometry: function(): (module:ol/geom/Geometry~Geometry|undefined),\n       *     setGeometry: function((module:ol/geom/Geometry~Geometry|undefined)): void\n       *   }|Feature|undefined}\n       * @protected\n       */\n      getGeometryTarget () {\n        return this.$feature\n      },\n      /**\n       * @return {Object}\n       * @protected\n       */\n      getServices () {\n        const vm = this\n\n        return mergeDescriptors(\n          this::olCmp.methods.getServices(),\n          this::geometryContainer.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n          {\n            get feature () { return vm.$feature },\n          },\n        )\n      },\n      /**\n       * @return {module:ol/Feature~Feature|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$feature\n      },\n      /**\n       * Checks if feature lies at `pixel`.\n       * @param {number[]} pixel\n       * @return {boolean}\n       */\n      isAtPixel (pixel) {\n        hasMap(this)\n\n        return this.$map.forEachFeatureAtPixel(\n          pixel,\n          f => f === this.$feature,\n          { layerFilter: l => l === this.$layer },\n        )\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this.$featuresContainer && this.$featuresContainer.addFeature(this)\n        this.subscribeAll()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.unsubscribeAll()\n        this.$featuresContainer && this.$featuresContainer.removeFeature(this)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::subscribeToEvents()\n      },\n    },\n    watch: {\n      /**\n       * @param {string|number} value\n       */\n      id (value) {\n        if (this.$feature && value !== getFeatureId(this.$feature)) {\n          setFeatureId(this.$feature, value)\n        }\n      },\n      /**\n       * @param {Object} value\n       */\n      properties (value) {\n        value = plainProps(value)\n        if (this.$feature && !isEqual(value, plainProps(this.$feature.getProperties()))) {\n          this.$feature.setProperties(value)\n        }\n      },\n    },\n    created () {\n      this::defineServices()\n    },\n  }\n\n  function defineServices () {\n    Object.defineProperties(this, {\n      $feature: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      $geometry: {\n        enumerable: true,\n        get: this.getGeometry,\n      },\n      $layer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.layer,\n      },\n      $map: {\n        enumerable: true,\n        get: () => this.$services && this.$services.map,\n      },\n      $view: {\n        enumerable: true,\n        get: () => this.$services && this.$services.view,\n      },\n      $featuresContainer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.featuresContainer,\n      },\n    })\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToEvents () {\n    hasFeature(this)\n\n    const getPropValue = prop => this.$feature.get(prop)\n    // all plain properties + geometry\n    const propChanges = observableFromOlEvent(\n      this.$feature,\n      'propertychange',\n      ({ key }) => ({ prop: key, value: getPropValue(key) }),\n    )\n    // id, style and other generic changes\n    const changes = observableFromOlEvent(\n      this.$feature,\n      'change',\n    ).pipe(\n      mapObs(() => Observable.create(obs => {\n        if (this.$feature.getId() !== this.id) {\n          obs.next({ prop: 'id', value: this.$feature.getId() })\n        }\n        // todo style?\n      })),\n      mergeAll(),\n    )\n    // all changes\n    const allChanges = mergeObs(propChanges, changes).pipe(\n      distinctUntilChanged(isEqual),\n    )\n\n    this.subscribeTo(allChanges, ({ prop, value }) => {\n      ++this.rev\n\n      this.$nextTick(() => {\n        if (prop === 'id') {\n          this.$emit(`update:${prop}`, value)\n        } else if (prop !== this.$feature.getGeometryName()) {\n          this.$emit('update:properties', { ...this.properties, [prop]: value })\n        }\n      })\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Feature from './feature.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Feature, options)\n\n  Vue.component(Feature.name, Feature)\n}\n\nexport default plugin\n\nexport {\n  Feature,\n  plugin as install,\n}\n"],"names":["name","mixins","olCmp","useMapCmp","geometryContainer","stylesContainer","projTransforms","props","properties","type","Object","default","computed","geometry","rev","resolvedDataProjection","$geometry","writeGeometryInDataProj","point","pointViewProj","pointToDataProj","geometryViewProj","writeGeometryInViewProj","findPointOnSurface","methods","createOlObject","feature","Feature","initializeFeature","id","setGeometry","getGeometryTarget","$feature","getServices","vm","mergeDescriptors","getStyleTarget","isAtPixel","pixel","hasMap","$map","forEachFeatureAtPixel","f","layerFilter","l","$layer","mount","$featuresContainer","addFeature","subscribeAll","unmount","unsubscribeAll","removeFeature","subscribeToEvents","watch","value","getFeatureId","setFeatureId","plainProps","isEqual","getProperties","setProperties","created","defineServices","enumerable","get","$olObject","getGeometry","$services","layer","$view","view","featuresContainer","hasFeature","getPropValue","prop","propChanges","observableFromOlEvent","key","changes","pipe","mapObs","Observable","create","obs","getId","next","mergeAll","allChanges","mergeObs","distinctUntilChanged","subscribeTo","$nextTick","$emit","getGeometryName","plugin","Vue","options","installed","pick","component"],"mappings":"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"}