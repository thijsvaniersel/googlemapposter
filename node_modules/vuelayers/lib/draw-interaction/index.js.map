{"version":3,"file":"index.js","sources":["src/component/draw-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/draw-interaction/interaction.vue","src/component/draw-interaction/index.js"],"sourcesContent":["\nimport { noModifierKeys, shiftKeyOnly } from 'ol/events/condition'\nimport { Collection } from 'ol'\nimport { Draw as DrawInteraction } from 'ol/interaction'\nimport { Vector as VectorSource } from 'ol/source'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { map as mapObs } from 'rxjs/operators'\nimport { interaction, stylesContainer } from '../../mixin'\nimport {\n  createStyle,\n  defaultEditStyle,\n  GEOMETRY_TYPE,\n  initializeFeature,\n} from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasInteraction, instanceOf } from '../../util/assert'\nimport { camelCase, mapValues, upperFirst } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nconst transformType = type => upperFirst(camelCase(type))\n\n/**\n * @alias module:draw-interaction/interaction\n * @title vl-interaction-draw\n * @vueProto\n */\nexport default {\n  name: 'vl-interaction-draw',\n  mixins: [interaction, stylesContainer],\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        id: this.vmId,\n        class: this.cmpName,\n      }\n    },\n  },\n  props: {\n    /**\n     * Target source or collection identifier from IdentityMap.\n     * @type {String}\n     */\n    source: {\n      type: String,\n      required: true,\n    },\n    /**\n     * The maximum distance in pixels between \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n     * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the\n     * draw interaction to behave correctly on mouse as well as on touch devices.\n     * @type {number}\n     */\n    clickTolerance: {\n      type: Number,\n      default: 6,\n    },\n    /**\n     * Pixel distance for snapping to the drawing finish.\n     * @type {number}\n     */\n    snapTolerance: {\n      type: Number,\n      default: 12,\n    },\n    /**\n     * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n     * @type {string}\n     */\n    type: {\n      type: String,\n      required: true,\n      validator: value => Object.values(GEOMETRY_TYPE).includes(transformType(value)),\n    },\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * @type {boolean}\n     */\n    stopClick: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The number of points that can be drawn before a polygon ring or line string is finished.\n     * @type {number|undefined}\n     */\n    maxPoints: Number,\n    /**\n     * The number of points that must be drawn before a polygon ring or line string can be finished.\n     * Default is `3` for polygon rings and `2` for line strings.\n     * @type {number|undefined}\n     */\n    minPoints: Number,\n    /**\n     * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.\n     * @type {function|undefined}\n     */\n    finishCondition: Function,\n    /**\n     * Function that is called when a geometry's coordinates are updated.\n     * @type {function|undefined}\n     */\n    geometryFunction: Function,\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string}\n     */\n    geometryName: {\n      type: String,\n      default: 'geometry',\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: noModifierKeys,\n    },\n    /**\n     * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in\n     * freehand mode and takes precedence over any `freehandCondition` option.\n     * @type {boolean}\n     */\n    freehand: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and\n     * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,\n     * meaning that the Shift key activates freehand drawing.\n     * @type {function|undefined}\n     */\n    freehandCondition: {\n      type: Function,\n      default: shiftKeyOnly,\n    },\n    /**\n     * Wrap the world horizontally on the sketch overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  methods: {\n    /**\n     * @return {Promise<Draw>}\n     * @protected\n     */\n    async createInteraction () {\n      let source = await this.getInstance(this.source)\n      instanceOf(source, VectorSource, `Source \"${this.source}\" doesn't exists in the identity map.`)\n      instanceOf(source.getFeaturesCollection(), Collection, `Source \"${this.source}\" doesn't provide features collection.`)\n\n      return new DrawInteraction({\n        features: source.getFeaturesCollection(),\n        clickTolerance: this.clickTolerance,\n        snapTolerance: this.snapTolerance,\n        type: transformType(this.type),\n        stopClick: this.stopClick,\n        maxPoints: this.maxPoints,\n        minPoints: this.minPoints,\n        finishCondition: this.finishCondition,\n        style: this.createStyleFunc(),\n        geometryFunction: this.geometryFunction,\n        geometryName: this.geometryName,\n        condition: this.condition,\n        freehand: this.freehand,\n        freehandCondition: this.freehandCondition,\n        wrapX: this.wrapX,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRecreate()\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::interaction.methods.subscribeAll()\n      this::subscribeToInteractionChanges()\n    },\n  },\n  watch: {\n    ...makeWatchers([\n      'source',\n      'clickTolerance',\n      'snapTolerance',\n      'type',\n      'stopClick',\n      'maxPoints',\n      'minPoints',\n      'finishCondition',\n      'geometryFunction',\n      'geometryName',\n      'condition',\n      'freehand',\n      'freehandCondition',\n      'wrapX',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const drawEvents = mergeObs(\n    observableFromOlEvent(this.$interaction, 'drawstart')\n      .pipe(\n        mapObs(evt => {\n          initializeFeature(evt.feature)\n          return evt\n        }),\n      ),\n    observableFromOlEvent(this.$interaction, 'drawend'),\n  )\n  this.subscribeTo(drawEvents, evt => {\n    ++this.rev\n\n    this.$nextTick(() => {\n      this.$emit(evt.type, evt)\n    })\n  })\n}\n","<script>\n  import { noModifierKeys, shiftKeyOnly } from 'ol/events/condition'\n  import { Collection } from 'ol'\n  import { Draw as DrawInteraction } from 'ol/interaction'\n  import { Vector as VectorSource } from 'ol/source'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { map as mapObs } from 'rxjs/operators'\n  import { interaction, stylesContainer } from '../../mixin'\n  import {\n    createStyle,\n    defaultEditStyle,\n    GEOMETRY_TYPE,\n    initializeFeature,\n  } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasInteraction, instanceOf } from '../../util/assert'\n  import { camelCase, mapValues, upperFirst } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  const transformType = type => upperFirst(camelCase(type))\n\n  /**\n   * @alias module:draw-interaction/interaction\n   * @title vl-interaction-draw\n   * @vueProto\n   */\n  export default {\n    name: 'vl-interaction-draw',\n    mixins: [interaction, stylesContainer],\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          id: this.vmId,\n          class: this.cmpName,\n        }\n      },\n    },\n    props: {\n      /**\n       * Target source or collection identifier from IdentityMap.\n       * @type {String}\n       */\n      source: {\n        type: String,\n        required: true,\n      },\n      /**\n       * The maximum distance in pixels between \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n       * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the\n       * draw interaction to behave correctly on mouse as well as on touch devices.\n       * @type {number}\n       */\n      clickTolerance: {\n        type: Number,\n        default: 6,\n      },\n      /**\n       * Pixel distance for snapping to the drawing finish.\n       * @type {number}\n       */\n      snapTolerance: {\n        type: Number,\n        default: 12,\n      },\n      /**\n       * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n       * @type {string}\n       */\n      type: {\n        type: String,\n        required: true,\n        validator: value => Object.values(GEOMETRY_TYPE).includes(transformType(value)),\n      },\n      /**\n       * Stop click, singleclick, and doubleclick events from firing during drawing.\n       * @type {boolean}\n       */\n      stopClick: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * The number of points that can be drawn before a polygon ring or line string is finished.\n       * @type {number|undefined}\n       */\n      maxPoints: Number,\n      /**\n       * The number of points that must be drawn before a polygon ring or line string can be finished.\n       * Default is `3` for polygon rings and `2` for line strings.\n       * @type {number|undefined}\n       */\n      minPoints: Number,\n      /**\n       * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.\n       * @type {function|undefined}\n       */\n      finishCondition: Function,\n      /**\n       * Function that is called when a geometry's coordinates are updated.\n       * @type {function|undefined}\n       */\n      geometryFunction: Function,\n      /**\n       * Name of the geometry attribute for newly created features.\n       * @type {string}\n       */\n      geometryName: {\n        type: String,\n        default: 'geometry',\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.\n       * @type {function|undefined}\n       */\n      condition: {\n        type: Function,\n        default: noModifierKeys,\n      },\n      /**\n       * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in\n       * freehand mode and takes precedence over any `freehandCondition` option.\n       * @type {boolean}\n       */\n      freehand: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and\n       * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,\n       * meaning that the Shift key activates freehand drawing.\n       * @type {function|undefined}\n       */\n      freehandCondition: {\n        type: Function,\n        default: shiftKeyOnly,\n      },\n      /**\n       * Wrap the world horizontally on the sketch overlay.\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: false,\n      },\n    },\n    methods: {\n      /**\n       * @return {Promise<Draw>}\n       * @protected\n       */\n      async createInteraction () {\n        let source = await this.getInstance(this.source)\n        instanceOf(source, VectorSource, `Source \"${this.source}\" doesn't exists in the identity map.`)\n        instanceOf(source.getFeaturesCollection(), Collection, `Source \"${this.source}\" doesn't provide features collection.`)\n\n        return new DrawInteraction({\n          features: source.getFeaturesCollection(),\n          clickTolerance: this.clickTolerance,\n          snapTolerance: this.snapTolerance,\n          type: transformType(this.type),\n          stopClick: this.stopClick,\n          maxPoints: this.maxPoints,\n          minPoints: this.minPoints,\n          finishCondition: this.finishCondition,\n          style: this.createStyleFunc(),\n          geometryFunction: this.geometryFunction,\n          geometryName: this.geometryName,\n          condition: this.condition,\n          freehand: this.freehand,\n          freehandCondition: this.freehandCondition,\n          wrapX: this.wrapX,\n        })\n      },\n      /**\n       * @return {function(feature: Feature): Style}\n       * @protected\n       */\n      getDefaultStyles () {\n        const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n        return function __selectDefaultStyleFunc (feature) {\n          if (feature.getGeometry()) {\n            return defaultStyles[feature.getGeometry().getType()]\n          }\n        }\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        return mergeDescriptors(\n          this::interaction.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n        )\n      },\n      /**\n       * @return {Interaction|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$interaction\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::interaction.methods.mount()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this::interaction.methods.unmount()\n      },\n      /**\n       * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n       * @return {void}\n       * @protected\n       */\n      setStyle (styles) {\n        if (styles !== this._styles) {\n          this._styles = styles\n          this.scheduleRecreate()\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::interaction.methods.subscribeAll()\n        this::subscribeToInteractionChanges()\n      },\n    },\n    watch: {\n      ...makeWatchers([\n        'source',\n        'clickTolerance',\n        'snapTolerance',\n        'type',\n        'stopClick',\n        'maxPoints',\n        'minPoints',\n        'finishCondition',\n        'geometryFunction',\n        'geometryName',\n        'condition',\n        'freehand',\n        'freehandCondition',\n        'wrapX',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const drawEvents = mergeObs(\n      observableFromOlEvent(this.$interaction, 'drawstart')\n        .pipe(\n          mapObs(evt => {\n            initializeFeature(evt.feature)\n            return evt\n          }),\n        ),\n      observableFromOlEvent(this.$interaction, 'drawend'),\n    )\n    this.subscribeTo(drawEvents, evt => {\n      ++this.rev\n\n      this.$nextTick(() => {\n        this.$emit(evt.type, evt)\n      })\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["transformType","type","upperFirst","camelCase","name","mixins","interaction","stylesContainer","stubVNode","empty","attrs","id","vmId","class","cmpName","props","source","String","required","clickTolerance","Number","default","snapTolerance","validator","value","GEOMETRY_TYPE","stopClick","Boolean","maxPoints","minPoints","finishCondition","Function","geometryFunction","geometryName","condition","noModifierKeys","freehand","freehandCondition","shiftKeyOnly","wrapX","methods","createInteraction","getInstance","instanceOf","VectorSource","getFeaturesCollection","Collection","DrawInteraction","features","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","createStyle","__selectDefaultStyleFunc","feature","getGeometry","getType","getServices","mergeDescriptors","getStyleTarget","$interaction","mount","unmount","setStyle","_styles","scheduleRecreate","subscribeAll","subscribeToInteractionChanges","watch","makeWatchers","hasInteraction","drawEvents","mergeObs","observableFromOlEvent","pipe","mapObs","evt","initializeFeature","subscribeTo","rev","$nextTick","$emit","plugin","Vue","options","installed","pick","Interaction","component"],"mappings":"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"}