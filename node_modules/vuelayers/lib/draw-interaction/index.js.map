{"version":3,"file":"index.js","sources":["src/component/draw-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/draw-interaction/interaction.vue","src/component/draw-interaction/index.js"],"sourcesContent":["\nimport { Collection } from 'ol'\nimport { noModifierKeys, shiftKeyOnly } from 'ol/events/condition'\nimport { Draw as DrawInteraction } from 'ol/interaction'\nimport { Vector as VectorSource } from 'ol/source'\nimport { from as fromObs, merge as mergeObs } from 'rxjs/observable'\nimport { map as mapObs, mapTo, mergeMap } from 'rxjs/operators'\nimport { interaction, stylesContainer } from '../../mixin'\nimport { createStyle, defaultEditStyle, GEOMETRY_TYPE, initializeFeature } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { assert, hasInteraction, instanceOf } from '../../util/assert'\nimport { camelCase, isFunction, mapValues, upperFirst } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nconst transformType = type => upperFirst(camelCase(type))\n\n/**\n * @alias module:draw-interaction/interaction\n * @title vl-interaction-draw\n * @vueProto\n */\nexport default {\n  name: 'vl-interaction-draw',\n  mixins: [interaction, stylesContainer],\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        id: this.vmId,\n        class: this.cmpName,\n      }\n    },\n  },\n  props: {\n    /**\n     * Target source or collection identifier from IdentityMap.\n     * @type {String}\n     */\n    source: {\n      type: String,\n      required: true,\n    },\n    /**\n     * The maximum distance in pixels between \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n     * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the\n     * draw interaction to behave correctly on mouse as well as on touch devices.\n     * @type {number}\n     */\n    clickTolerance: {\n      type: Number,\n      default: 6,\n    },\n    /**\n     * Pixel distance for snapping to the drawing finish.\n     * @type {number}\n     */\n    snapTolerance: {\n      type: Number,\n      default: 12,\n    },\n    /**\n     * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n     * @type {string}\n     */\n    type: {\n      type: String,\n      required: true,\n      validator: value => Object.values(GEOMETRY_TYPE).includes(transformType(value)),\n    },\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * @type {boolean}\n     */\n    stopClick: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The number of points that can be drawn before a polygon ring or line string is finished.\n     * @type {number|undefined}\n     */\n    maxPoints: Number,\n    /**\n     * The number of points that must be drawn before a polygon ring or line string can be finished.\n     * Default is `3` for polygon rings and `2` for line strings.\n     * @type {number|undefined}\n     */\n    minPoints: Number,\n    /**\n     * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.\n     * @type {function|undefined}\n     */\n    finishCondition: Function,\n    /**\n     * Function that is called when a geometry's coordinates are updated.\n     * @type {function|undefined}\n     */\n    geometryFunction: Function,\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string}\n     */\n    geometryName: {\n      type: String,\n      default: 'geometry',\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: noModifierKeys,\n    },\n    /**\n     * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in\n     * freehand mode and takes precedence over any `freehandCondition` option.\n     * @type {boolean}\n     */\n    freehand: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and\n     * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,\n     * meaning that the Shift key activates freehand drawing.\n     * @type {function|undefined}\n     */\n    freehandCondition: {\n      type: Function,\n      default: shiftKeyOnly,\n    },\n    /**\n     * Wrap the world horizontally on the sketch overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  methods: {\n    /**\n     * @return {Promise<Draw>}\n     * @protected\n     */\n    async createInteraction () {\n      let source = await this.getInstance(this.source)\n      assert(!!source, `Source \"${this.source}\" not found in identity map.`)\n      let features\n      if (!(source instanceof VectorSource)) {\n        if (isFunction(source.getFeaturesCollection)) {\n          features = source.getFeaturesCollection()\n        } else if (isFunction(source.getFeatures)) {\n          features = source.getFeatures()\n        }\n        instanceOf(features, Collection, `Source \"${this.source}\" doesn't provide features collection.`)\n        source = null\n      }\n\n      return new DrawInteraction({\n        source,\n        features,\n        clickTolerance: this.clickTolerance,\n        snapTolerance: this.snapTolerance,\n        type: transformType(this.type),\n        stopClick: this.stopClick,\n        maxPoints: this.maxPoints,\n        minPoints: this.minPoints,\n        finishCondition: this.finishCondition,\n        style: this.createStyleFunc(),\n        geometryFunction: this.geometryFunction,\n        geometryName: this.geometryName,\n        condition: this.condition,\n        freehand: this.freehand,\n        freehandCondition: this.freehandCondition,\n        wrapX: this.wrapX,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRecreate()\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::interaction.methods.subscribeAll()\n      this::subscribeToInteractionChanges()\n    },\n  },\n  watch: {\n    ...makeWatchers([\n      'source',\n      'clickTolerance',\n      'snapTolerance',\n      'type',\n      'stopClick',\n      'maxPoints',\n      'minPoints',\n      'finishCondition',\n      'geometryFunction',\n      'geometryName',\n      'condition',\n      'freehand',\n      'freehandCondition',\n      'wrapX',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const drawEvents = mergeObs(\n    observableFromOlEvent(this.$interaction, 'drawstart')\n      .pipe(\n        mapObs(evt => {\n          initializeFeature(evt.feature)\n          return evt\n        }),\n      ),\n    observableFromOlEvent(this.$interaction, 'drawend').pipe(\n      // FIXME blood patch, wait for vl-vector-source featuresDataProj watcher to trigger\n      mergeMap(evt => fromObs(Promise.resolve(this.getInstance(this.source))).pipe(\n        mergeMap(source => fromObs(new Promise(resolve => {\n          setTimeout(resolve, 1000 / 60)\n        }))),\n        mapTo(evt),\n      )),\n    ),\n  )\n  this.subscribeTo(drawEvents, evt => {\n    ++this.rev\n\n    this.$nextTick(() => {\n      this.$emit(evt.type, evt)\n    })\n  })\n}\n","<script>\n  import { Collection } from 'ol'\n  import { noModifierKeys, shiftKeyOnly } from 'ol/events/condition'\n  import { Draw as DrawInteraction } from 'ol/interaction'\n  import { Vector as VectorSource } from 'ol/source'\n  import { from as fromObs, merge as mergeObs } from 'rxjs/observable'\n  import { map as mapObs, mapTo, mergeMap } from 'rxjs/operators'\n  import { interaction, stylesContainer } from '../../mixin'\n  import { createStyle, defaultEditStyle, GEOMETRY_TYPE, initializeFeature } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { assert, hasInteraction, instanceOf } from '../../util/assert'\n  import { camelCase, isFunction, mapValues, upperFirst } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  const transformType = type => upperFirst(camelCase(type))\n\n  /**\n   * @alias module:draw-interaction/interaction\n   * @title vl-interaction-draw\n   * @vueProto\n   */\n  export default {\n    name: 'vl-interaction-draw',\n    mixins: [interaction, stylesContainer],\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          id: this.vmId,\n          class: this.cmpName,\n        }\n      },\n    },\n    props: {\n      /**\n       * Target source or collection identifier from IdentityMap.\n       * @type {String}\n       */\n      source: {\n        type: String,\n        required: true,\n      },\n      /**\n       * The maximum distance in pixels between \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n       * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the\n       * draw interaction to behave correctly on mouse as well as on touch devices.\n       * @type {number}\n       */\n      clickTolerance: {\n        type: Number,\n        default: 6,\n      },\n      /**\n       * Pixel distance for snapping to the drawing finish.\n       * @type {number}\n       */\n      snapTolerance: {\n        type: Number,\n        default: 12,\n      },\n      /**\n       * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n       * @type {string}\n       */\n      type: {\n        type: String,\n        required: true,\n        validator: value => Object.values(GEOMETRY_TYPE).includes(transformType(value)),\n      },\n      /**\n       * Stop click, singleclick, and doubleclick events from firing during drawing.\n       * @type {boolean}\n       */\n      stopClick: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * The number of points that can be drawn before a polygon ring or line string is finished.\n       * @type {number|undefined}\n       */\n      maxPoints: Number,\n      /**\n       * The number of points that must be drawn before a polygon ring or line string can be finished.\n       * Default is `3` for polygon rings and `2` for line strings.\n       * @type {number|undefined}\n       */\n      minPoints: Number,\n      /**\n       * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.\n       * @type {function|undefined}\n       */\n      finishCondition: Function,\n      /**\n       * Function that is called when a geometry's coordinates are updated.\n       * @type {function|undefined}\n       */\n      geometryFunction: Function,\n      /**\n       * Name of the geometry attribute for newly created features.\n       * @type {string}\n       */\n      geometryName: {\n        type: String,\n        default: 'geometry',\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.\n       * @type {function|undefined}\n       */\n      condition: {\n        type: Function,\n        default: noModifierKeys,\n      },\n      /**\n       * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in\n       * freehand mode and takes precedence over any `freehandCondition` option.\n       * @type {boolean}\n       */\n      freehand: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and\n       * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,\n       * meaning that the Shift key activates freehand drawing.\n       * @type {function|undefined}\n       */\n      freehandCondition: {\n        type: Function,\n        default: shiftKeyOnly,\n      },\n      /**\n       * Wrap the world horizontally on the sketch overlay.\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: false,\n      },\n    },\n    methods: {\n      /**\n       * @return {Promise<Draw>}\n       * @protected\n       */\n      async createInteraction () {\n        let source = await this.getInstance(this.source)\n        assert(!!source, `Source \"${this.source}\" not found in identity map.`)\n        let features\n        if (!(source instanceof VectorSource)) {\n          if (isFunction(source.getFeaturesCollection)) {\n            features = source.getFeaturesCollection()\n          } else if (isFunction(source.getFeatures)) {\n            features = source.getFeatures()\n          }\n          instanceOf(features, Collection, `Source \"${this.source}\" doesn't provide features collection.`)\n          source = null\n        }\n\n        return new DrawInteraction({\n          source,\n          features,\n          clickTolerance: this.clickTolerance,\n          snapTolerance: this.snapTolerance,\n          type: transformType(this.type),\n          stopClick: this.stopClick,\n          maxPoints: this.maxPoints,\n          minPoints: this.minPoints,\n          finishCondition: this.finishCondition,\n          style: this.createStyleFunc(),\n          geometryFunction: this.geometryFunction,\n          geometryName: this.geometryName,\n          condition: this.condition,\n          freehand: this.freehand,\n          freehandCondition: this.freehandCondition,\n          wrapX: this.wrapX,\n        })\n      },\n      /**\n       * @return {function(feature: Feature): Style}\n       * @protected\n       */\n      getDefaultStyles () {\n        const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n        return function __selectDefaultStyleFunc (feature) {\n          if (feature.getGeometry()) {\n            return defaultStyles[feature.getGeometry().getType()]\n          }\n        }\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        return mergeDescriptors(\n          this::interaction.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n        )\n      },\n      /**\n       * @return {Interaction|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$interaction\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::interaction.methods.mount()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this::interaction.methods.unmount()\n      },\n      /**\n       * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n       * @return {void}\n       * @protected\n       */\n      setStyle (styles) {\n        if (styles !== this._styles) {\n          this._styles = styles\n          this.scheduleRecreate()\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::interaction.methods.subscribeAll()\n        this::subscribeToInteractionChanges()\n      },\n    },\n    watch: {\n      ...makeWatchers([\n        'source',\n        'clickTolerance',\n        'snapTolerance',\n        'type',\n        'stopClick',\n        'maxPoints',\n        'minPoints',\n        'finishCondition',\n        'geometryFunction',\n        'geometryName',\n        'condition',\n        'freehand',\n        'freehandCondition',\n        'wrapX',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const drawEvents = mergeObs(\n      observableFromOlEvent(this.$interaction, 'drawstart')\n        .pipe(\n          mapObs(evt => {\n            initializeFeature(evt.feature)\n            return evt\n          }),\n        ),\n      observableFromOlEvent(this.$interaction, 'drawend').pipe(\n        // FIXME blood patch, wait for vl-vector-source featuresDataProj watcher to trigger\n        mergeMap(evt => fromObs(Promise.resolve(this.getInstance(this.source))).pipe(\n          mergeMap(source => fromObs(new Promise(resolve => {\n            setTimeout(resolve, 1000 / 60)\n          }))),\n          mapTo(evt),\n        )),\n      ),\n    )\n    this.subscribeTo(drawEvents, evt => {\n      ++this.rev\n\n      this.$nextTick(() => {\n        this.$emit(evt.type, evt)\n      })\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["transformType","type","upperFirst","camelCase","name","mixins","interaction","stylesContainer","stubVNode","empty","attrs","id","vmId","class","cmpName","props","source","String","required","clickTolerance","Number","default","snapTolerance","validator","value","GEOMETRY_TYPE","stopClick","Boolean","maxPoints","minPoints","finishCondition","Function","geometryFunction","geometryName","condition","noModifierKeys","freehand","freehandCondition","shiftKeyOnly","wrapX","methods","createInteraction","getInstance","assert","VectorSource","isFunction","getFeaturesCollection","features","getFeatures","instanceOf","Collection","DrawInteraction","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","createStyle","__selectDefaultStyleFunc","feature","getGeometry","getType","getServices","mergeDescriptors","getStyleTarget","$interaction","mount","unmount","setStyle","_styles","scheduleRecreate","subscribeAll","subscribeToInteractionChanges","watch","makeWatchers","hasInteraction","drawEvents","mergeObs","observableFromOlEvent","pipe","mapObs","evt","initializeFeature","mergeMap","fromObs","resolve","mapTo","subscribeTo","rev","$nextTick","$emit","plugin","Vue","options","installed","pick","Interaction","component"],"mappings":"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"}