{"version":3,"file":"index.js","sources":["src/component/modify-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/modify-interaction/interaction.vue","src/component/modify-interaction/index.js"],"sourcesContent":["\nimport { altKeyOnly, always, primaryAction } from 'ol/events/condition'\nimport { Collection } from 'ol'\nimport { Modify as ModifyInteraction } from 'ol/interaction'\nimport { Vector as VectorSource } from 'ol/source'\nimport { interaction, stylesContainer } from '../../mixin'\nimport { createStyle, defaultEditStyle } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasInteraction, instanceOf } from '../../util/assert'\nimport { mapValues } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\n/**\n * @vueProto\n * @alias module:modify-interaction/interaction\n * @title vl-interaction-modify\n */\nexport default {\n  name: 'vl-interaction-modify',\n  mixins: [interaction, stylesContainer],\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        id: this.vmId,\n        class: this.cmpName,\n      }\n    },\n  },\n  props: {\n    /**\n     * Source or collection identifier from IdentityMap.\n     * @type {String}\n     */\n    source: {\n      type: String,\n      required: true,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event will be\n     * considered to add or move a vertex to the sketch. Default is `ol.events.condition.primaryAction`.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: primaryAction,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default, `ol.events.condition.singleClick` with `ol.events.condition.altKeyOnly` results in a vertex deletion.\n     * @type {function|undefined}\n     */\n    deleteCondition: {\n      type: Function,\n      default: altKeyOnly,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether a new vertex can be added\n     * to the sketch features. Default is `ol.events.condition.always`.\n     * @type {function|undefined}\n     */\n    insertVertexCondition: {\n      type: Function,\n      default: always,\n    },\n    /**\n     * Pixel tolerance for considering the pointer close enough to a segment or vertex for editing.\n     * @type {number}\n     */\n    pixelTolerance: {\n      type: Number,\n      default: 10,\n    },\n    /**\n     * Wrap the world horizontally on the sketch overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  methods: {\n    /**\n     * @return {Promise<Modify>}\n     * @protected\n     */\n    async createInteraction () {\n      let source = await this.getInstance(this.source)\n      instanceOf(source, VectorSource, `Source \"${this.source}\" doesn't exists in the identity map.`)\n      instanceOf(source.getFeaturesCollection(), Collection, `Source \"${this.source}\" doesn't provide features collection.`)\n\n      return new ModifyInteraction({\n        features: source.getFeaturesCollection(),\n        deleteCondition: this.deleteCondition,\n        insertVertexCondition: this.insertVertexCondition,\n        pixelTolerance: this.pixelTolerance,\n        style: this.createStyleFunc(),\n        wrapX: this.wrapX,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRecreate()\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::interaction.methods.subscribeAll()\n      this::subscribeToInteractionChanges()\n    },\n  },\n  watch: {\n    ...makeWatchers([\n      'source',\n      'condition',\n      'deleteCondition',\n      'insertVertexCondition',\n      'pixelTolerance',\n      'wrapX',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const modifyEvents = observableFromOlEvent(this.$interaction, ['modifystart', 'modifyend'])\n  this.subscribeTo(modifyEvents, evt => {\n    ++this.rev\n\n    this.$nextTick(() => {\n      this.$emit(evt.type, evt)\n    })\n  })\n}\n","<script>\n  import { altKeyOnly, always, primaryAction } from 'ol/events/condition'\n  import { Collection } from 'ol'\n  import { Modify as ModifyInteraction } from 'ol/interaction'\n  import { Vector as VectorSource } from 'ol/source'\n  import { interaction, stylesContainer } from '../../mixin'\n  import { createStyle, defaultEditStyle } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasInteraction, instanceOf } from '../../util/assert'\n  import { mapValues } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  /**\n   * @vueProto\n   * @alias module:modify-interaction/interaction\n   * @title vl-interaction-modify\n   */\n  export default {\n    name: 'vl-interaction-modify',\n    mixins: [interaction, stylesContainer],\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          id: this.vmId,\n          class: this.cmpName,\n        }\n      },\n    },\n    props: {\n      /**\n       * Source or collection identifier from IdentityMap.\n       * @type {String}\n       */\n      source: {\n        type: String,\n        required: true,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event will be\n       * considered to add or move a vertex to the sketch. Default is `ol.events.condition.primaryAction`.\n       * @type {function|undefined}\n       */\n      condition: {\n        type: Function,\n        default: primaryAction,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * By default, `ol.events.condition.singleClick` with `ol.events.condition.altKeyOnly` results in a vertex deletion.\n       * @type {function|undefined}\n       */\n      deleteCondition: {\n        type: Function,\n        default: altKeyOnly,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether a new vertex can be added\n       * to the sketch features. Default is `ol.events.condition.always`.\n       * @type {function|undefined}\n       */\n      insertVertexCondition: {\n        type: Function,\n        default: always,\n      },\n      /**\n       * Pixel tolerance for considering the pointer close enough to a segment or vertex for editing.\n       * @type {number}\n       */\n      pixelTolerance: {\n        type: Number,\n        default: 10,\n      },\n      /**\n       * Wrap the world horizontally on the sketch overlay.\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: false,\n      },\n    },\n    methods: {\n      /**\n       * @return {Promise<Modify>}\n       * @protected\n       */\n      async createInteraction () {\n        let source = await this.getInstance(this.source)\n        instanceOf(source, VectorSource, `Source \"${this.source}\" doesn't exists in the identity map.`)\n        instanceOf(source.getFeaturesCollection(), Collection, `Source \"${this.source}\" doesn't provide features collection.`)\n\n        return new ModifyInteraction({\n          features: source.getFeaturesCollection(),\n          deleteCondition: this.deleteCondition,\n          insertVertexCondition: this.insertVertexCondition,\n          pixelTolerance: this.pixelTolerance,\n          style: this.createStyleFunc(),\n          wrapX: this.wrapX,\n        })\n      },\n      /**\n       * @return {function(feature: Feature): Style}\n       * @protected\n       */\n      getDefaultStyles () {\n        const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n        return function __selectDefaultStyleFunc (feature) {\n          if (feature.getGeometry()) {\n            return defaultStyles[feature.getGeometry().getType()]\n          }\n        }\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        return mergeDescriptors(\n          this::interaction.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n        )\n      },\n      /**\n       * @return {Interaction|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$interaction\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::interaction.methods.mount()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this::interaction.methods.unmount()\n      },\n      /**\n       * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n       * @return {void}\n       * @protected\n       */\n      setStyle (styles) {\n        if (styles !== this._styles) {\n          this._styles = styles\n          this.scheduleRecreate()\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::interaction.methods.subscribeAll()\n        this::subscribeToInteractionChanges()\n      },\n    },\n    watch: {\n      ...makeWatchers([\n        'source',\n        'condition',\n        'deleteCondition',\n        'insertVertexCondition',\n        'pixelTolerance',\n        'wrapX',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const modifyEvents = observableFromOlEvent(this.$interaction, ['modifystart', 'modifyend'])\n    this.subscribeTo(modifyEvents, evt => {\n      ++this.rev\n\n      this.$nextTick(() => {\n        this.$emit(evt.type, evt)\n      })\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["name","mixins","interaction","stylesContainer","stubVNode","empty","attrs","id","vmId","class","cmpName","props","source","type","String","required","condition","Function","default","primaryAction","deleteCondition","altKeyOnly","insertVertexCondition","always","pixelTolerance","Number","wrapX","Boolean","methods","createInteraction","getInstance","instanceOf","VectorSource","getFeaturesCollection","Collection","ModifyInteraction","features","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","createStyle","__selectDefaultStyleFunc","feature","getGeometry","getType","getServices","mergeDescriptors","getStyleTarget","$interaction","mount","unmount","setStyle","_styles","scheduleRecreate","subscribeAll","subscribeToInteractionChanges","watch","makeWatchers","hasInteraction","modifyEvents","observableFromOlEvent","subscribeTo","evt","rev","$nextTick","$emit","plugin","Vue","options","installed","pick","Interaction","component"],"mappings":"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"}